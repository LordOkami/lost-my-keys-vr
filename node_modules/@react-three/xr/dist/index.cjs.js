'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _extends = require('@babel/runtime/helpers/extends');
var _objectWithoutPropertiesLoose = require('@babel/runtime/helpers/objectWithoutPropertiesLoose');
var React = require('react');
var fiber = require('@react-three/fiber');
var _asyncToGenerator = require('@babel/runtime/helpers/asyncToGenerator');
var three = require('three');
var mergeRefs = require('react-merge-refs');
var _inheritsLoose = require('@babel/runtime/helpers/inheritsLoose');
var GLTFLoader = require('three/examples/jsm/loaders/GLTFLoader');
var motionControllers = require('@webxr-input-profiles/motion-controllers');
var _assertThisInitialized = require('@babel/runtime/helpers/assertThisInitialized');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () {
            return e[k];
          }
        });
      }
    });
  }
  n['default'] = e;
  return Object.freeze(n);
}

var _extends__default = /*#__PURE__*/_interopDefaultLegacy(_extends);
var _objectWithoutPropertiesLoose__default = /*#__PURE__*/_interopDefaultLegacy(_objectWithoutPropertiesLoose);
var React__default = /*#__PURE__*/_interopDefaultLegacy(React);
var React__namespace = /*#__PURE__*/_interopNamespace(React);
var _asyncToGenerator__default = /*#__PURE__*/_interopDefaultLegacy(_asyncToGenerator);
var mergeRefs__default = /*#__PURE__*/_interopDefaultLegacy(mergeRefs);
var _inheritsLoose__default = /*#__PURE__*/_interopDefaultLegacy(_inheritsLoose);
var _assertThisInitialized__default = /*#__PURE__*/_interopDefaultLegacy(_assertThisInitialized);

var ARButton = /*#__PURE__*/function () {
  function ARButton() {}

  ARButton.createButton = function createButton(renderer, sessionInit) {
    if (sessionInit === void 0) {
      sessionInit = {};
    }

    var button = document.createElement('button');

    function showStartAR()
    /*device*/
    {
      if (sessionInit.domOverlay === undefined) {
        var overlay = document.createElement('div');
        overlay.style.display = 'none';
        document.body.appendChild(overlay);
        var svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        svg.setAttribute('width', 38);
        svg.setAttribute('height', 38);
        svg.style.position = 'absolute';
        svg.style.right = '20px';
        svg.style.top = '20px';
        svg.addEventListener('click', function () {
          currentSession.end();
        });
        overlay.appendChild(svg);
        var path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        path.setAttribute('d', 'M 12,12 L 28,28 M 28,12 12,28');
        path.setAttribute('stroke', '#fff');
        path.setAttribute('stroke-width', 2);
        svg.appendChild(path);

        if (sessionInit.optionalFeatures === undefined) {
          sessionInit.optionalFeatures = [];
        }

        sessionInit.optionalFeatures.push('dom-overlay');
        sessionInit.domOverlay = {
          root: overlay
        };
      } //


      var currentSession = null;

      function onSessionStarted(_x) {
        return _onSessionStarted.apply(this, arguments);
      }

      function _onSessionStarted() {
        _onSessionStarted = _asyncToGenerator__default['default']( /*#__PURE__*/regeneratorRuntime.mark(function _callee(session) {
          return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  session.addEventListener('end', onSessionEnded);
                  renderer.xr.setReferenceSpaceType('local');
                  _context.next = 4;
                  return renderer.xr.setSession(session);

                case 4:
                  button.textContent = 'STOP AR';
                  sessionInit.domOverlay.root.style.display = '';
                  currentSession = session;

                case 7:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }));
        return _onSessionStarted.apply(this, arguments);
      }

      function onSessionEnded()
      /*event*/
      {
        currentSession.removeEventListener('end', onSessionEnded);
        button.textContent = 'START AR';
        sessionInit.domOverlay.root.style.display = 'none';
        currentSession = null;
      } //


      button.style.display = '';
      button.style.cursor = 'pointer';
      button.style.left = 'calc(50% - 50px)';
      button.style.width = '100px';
      button.textContent = 'START AR';

      button.onmouseenter = function () {
        button.style.opacity = '1.0';
      };

      button.onmouseleave = function () {
        button.style.opacity = '0.5';
      };

      button.onclick = function () {
        if (currentSession === null) {
          navigator.xr.requestSession('immersive-ar', sessionInit).then(onSessionStarted);
        } else {
          currentSession.end();
        }
      };
    }

    function disableButton() {
      button.style.display = '';
      button.style.cursor = 'auto';
      button.style.left = 'calc(50% - 75px)';
      button.style.width = '150px';
      button.onmouseenter = null;
      button.onmouseleave = null;
      button.onclick = null;
    }

    function showARNotSupported() {
      disableButton();
      button.textContent = 'AR NOT SUPPORTED';
    }

    function stylizeElement(element) {
      element.style.position = 'absolute';
      element.style.bottom = '20px';
      element.style.padding = '12px 6px';
      element.style.border = '1px solid #fff';
      element.style.borderRadius = '4px';
      element.style.background = 'rgba(0,0,0,0.1)';
      element.style.color = '#fff';
      element.style.font = 'normal 13px sans-serif';
      element.style.textAlign = 'center';
      element.style.opacity = '0.5';
      element.style.outline = 'none';
      element.style.zIndex = '999';
    }

    if ('xr' in navigator) {
      button.id = 'ARButton';
      button.style.display = 'none';
      stylizeElement(button);
      navigator.xr.isSessionSupported('immersive-ar').then(function (supported) {
        supported ? showStartAR() : showARNotSupported();
      })["catch"](showARNotSupported);
      return button;
    } else {
      var message = document.createElement('a');

      if (window.isSecureContext === false) {
        message.href = document.location.href.replace(/^http:/, 'https:');
        message.innerHTML = 'WEBXR NEEDS HTTPS'; // TODO Improve message
      } else {
        message.href = 'https://immersiveweb.dev/';
        message.innerHTML = 'WEBXR NOT AVAILABLE';
      }

      message.style.left = 'calc(50% - 90px)';
      message.style.width = '180px';
      message.style.textDecoration = 'none';
      stylizeElement(message);
      return message;
    }
  };

  return ARButton;
}();

var VRButton = /*#__PURE__*/function () {
  function VRButton() {}

  VRButton.createButton = function createButton(renderer, sessionInit) {
    if (sessionInit === void 0) {
      sessionInit = {};
    }

    var button = document.createElement('button');

    function showEnterVR()
    /*device*/
    {
      var currentSession = null;

      function onSessionStarted(_x) {
        return _onSessionStarted.apply(this, arguments);
      }

      function _onSessionStarted() {
        _onSessionStarted = _asyncToGenerator__default['default']( /*#__PURE__*/regeneratorRuntime.mark(function _callee(session) {
          return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  session.addEventListener('end', onSessionEnded);
                  _context.next = 3;
                  return renderer.xr.setSession(session);

                case 3:
                  button.textContent = 'EXIT VR';
                  currentSession = session;

                case 5:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }));
        return _onSessionStarted.apply(this, arguments);
      }

      function onSessionEnded()
      /*event*/
      {
        currentSession.removeEventListener('end', onSessionEnded);
        button.textContent = 'ENTER VR';
        currentSession = null;
      } //


      button.style.display = '';
      button.style.cursor = 'pointer';
      button.style.left = 'calc(50% - 50px)';
      button.style.width = '100px';
      button.textContent = 'ENTER VR';

      button.onmouseenter = function () {
        button.style.opacity = '1.0';
      };

      button.onmouseleave = function () {
        button.style.opacity = '0.5';
      };

      button.onclick = function () {
        if (currentSession === null) {
          // WebXR's requestReferenceSpace only works if the corresponding feature
          // was requested at session creation time. For simplicity, just ask for
          // the interesting ones as optional features, but be aware that the
          // requestReferenceSpace call will fail if it turns out to be unavailable.
          // ('local' is always available for immersive sessions and doesn't need to
          // be requested separately.)
          var optionalFeatures = [sessionInit.optionalFeatures, 'local-floor', 'bounded-floor', 'hand-tracking'].flat().filter(Boolean);
          sessionInit.optionalFeatures = navigator.xr.requestSession('immersive-vr', _extends__default['default'](_extends__default['default']({}, sessionInit), {}, {
            optionalFeatures: optionalFeatures
          })).then(onSessionStarted);
        } else {
          currentSession.end();
        }
      };
    }

    function disableButton() {
      button.style.display = '';
      button.style.cursor = 'auto';
      button.style.left = 'calc(50% - 75px)';
      button.style.width = '150px';
      button.onmouseenter = null;
      button.onmouseleave = null;
      button.onclick = null;
    }

    function showWebXRNotFound() {
      disableButton();
      button.textContent = 'VR NOT SUPPORTED';
    }

    function stylizeElement(element) {
      element.style.position = 'absolute';
      element.style.bottom = '20px';
      element.style.padding = '12px 6px';
      element.style.border = '1px solid #fff';
      element.style.borderRadius = '4px';
      element.style.background = 'rgba(0,0,0,0.1)';
      element.style.color = '#fff';
      element.style.font = 'normal 13px sans-serif';
      element.style.textAlign = 'center';
      element.style.opacity = '0.5';
      element.style.outline = 'none';
      element.style.zIndex = '999';
    }

    if ('xr' in navigator) {
      button.id = 'VRButton';
      button.style.display = 'none';
      stylizeElement(button);
      navigator.xr.isSessionSupported('immersive-vr').then(function (supported) {
        supported ? showEnterVR() : showWebXRNotFound();
      });
      return button;
    } else {
      var message = document.createElement('a');

      if (window.isSecureContext === false) {
        message.href = document.location.href.replace(/^http:/, 'https:');
        message.innerHTML = 'WEBXR NEEDS HTTPS'; // TODO Improve message
      } else {
        message.href = 'https://immersiveweb.dev/';
        message.innerHTML = 'WEBXR NOT AVAILABLE';
      }

      message.style.left = 'calc(50% - 90px)';
      message.style.width = '180px';
      message.style.textDecoration = 'none';
      stylizeElement(message);
      return message;
    }
  };

  return VRButton;
}();

var XRController = {
  make: function make(id, gl, onConnected, onDisconnected) {
    var controller = gl.xr.getController(id);
    var grip = gl.xr.getControllerGrip(id);
    var hand = gl.xr.getHand(id);
    var xrController = {
      inputSource: undefined,
      grip: grip,
      controller: controller,
      hand: hand
    };
    grip.userData.name = 'grip';
    controller.userData.name = 'controller';
    hand.userData.name = 'hand';
    controller.addEventListener('connected', function (event) {
      if (event.fake) {
        return;
      }

      xrController.inputSource = event.data;
      onConnected(xrController);
    });
    controller.addEventListener('disconnected', function (_) {
      onDisconnected(xrController);
    });
  }
};

/**
 * Store data associated with some objects in the scene
 *
 * For example storing event handlers:
 *
 * objectA:
 *   onClick: [handler, handler]
 * objectB:
 *   onHover: [handler]
 *   onBlur:  [handler]
 *
 */
var ObjectsState = {
  make: function make() {
    return new Map();
  },
  add: function add(state, object, key, value) {
    if (!state.has(object)) {
      state.set(object, {
        key: [value]
      });
    }

    var entry = state.get(object);

    if (!entry[key]) {
      entry[key] = [];
    }

    entry[key].push(value);
  },
  "delete": function _delete(state, object, key, value) {
    var entry = state.get(object);
    if (!entry || !entry[key]) return;
    entry[key] = entry[key].filter(function (it) {
      return it !== value;
    });

    if (entry[key].length === 0) {
      delete entry[key];
    } // Remove entry if nothing left


    if (Object.keys(entry).length === 0) {
      state["delete"](object);
    }
  },
  has: function has(state, object, key) {
    var entry = state.get(object);
    return !!(entry && entry[key]);
  },
  get: function get(state, object, key) {
    var entry = state.get(object);
    return entry && entry[key];
  }
};

var useXREvent = function useXREvent(event, handler, _temp) {
  var _ref = _temp === void 0 ? {} : _temp,
      handedness = _ref.handedness;

  var handlerRef = React__default['default'].useRef(handler);
  React__default['default'].useEffect(function () {
    handlerRef.current = handler;
  }, [handler]);

  var _useXR = useXR(),
      allControllers = _useXR.controllers;

  React__default['default'].useEffect(function () {
    var controllers = handedness ? allControllers.filter(function (it) {
      return it.inputSource.handedness === handedness;
    }) : allControllers;
    var cleanups = [];
    controllers.forEach(function (it) {
      var listener = function listener(e) {
        return handlerRef.current({
          originalEvent: e,
          controller: it
        });
      };

      it.controller.addEventListener(event, listener);
      cleanups.push(function () {
        return it.controller.removeEventListener(event, listener);
      });
    });
    return function () {
      return cleanups.forEach(function (fn) {
        return fn();
      });
    };
  }, [event, allControllers, handedness]);
};

function _createForOfIteratorHelperLoose(o) { var i = 0; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } i = o[Symbol.iterator](); return i.next.bind(i); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
var InteractionsContext = React__default['default'].createContext({});
function InteractionManager(_ref) {
  var children = _ref.children;

  var _useXR = useXR(),
      controllers = _useXR.controllers;

  var _React$useState = React__default['default'].useState(function () {
    return {
      left: new Map(),
      right: new Map(),
      none: new Map()
    };
  }),
      hoverState = _React$useState[0];

  var _React$useState2 = React__default['default'].useState(function () {
    return ObjectsState.make();
  }),
      interactions = _React$useState2[0];

  var addInteraction = React__default['default'].useCallback(function (object, eventType, handler) {
    ObjectsState.add(interactions, object, eventType, handler);
  }, [interactions]);
  var removeInteraction = React__default['default'].useCallback(function (object, eventType, handler) {
    ObjectsState["delete"](interactions, object, eventType, handler);
  }, [interactions]);

  var _React$useState3 = React__default['default'].useState(function () {
    return new three.Raycaster();
  }),
      raycaster = _React$useState3[0];

  var intersect = React__default['default'].useCallback(function (controller) {
    var objects = Array.from(interactions.keys());
    var tempMatrix = new three.Matrix4();
    tempMatrix.identity().extractRotation(controller.matrixWorld);
    raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
    raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);
    return raycaster.intersectObjects(objects, true);
  }, [interactions, raycaster]); // Trigger hover and blur events

  fiber.useFrame(function () {
    if (interactions.size === 0) {
      return;
    }

    controllers.forEach(function (it) {
      var controller = it.controller;
      var handedness = it.inputSource.handedness;
      var hovering = hoverState[handedness];
      var hits = new Set();
      var intersections = intersect(controller);
      intersections.forEach(function (intersection) {
        var eventObject = intersection.object;

        while (eventObject) {
          if (ObjectsState.has(interactions, eventObject, 'onHover') && !hovering.has(eventObject)) {
            var _ObjectsState$get;

            (_ObjectsState$get = ObjectsState.get(interactions, eventObject, 'onHover')) == null ? void 0 : _ObjectsState$get.forEach(function (handler) {
              return handler({
                controller: it,
                intersection: intersection
              });
            });
          }

          hovering.set(eventObject, intersection);
          hits.add(eventObject.id);
          eventObject = eventObject.parent;
        }
      }); // Trigger blur on all the object that were hovered in the previous frame
      // but missed in this one

      for (var _iterator = _createForOfIteratorHelperLoose(hovering.keys()), _step; !(_step = _iterator()).done;) {
        var eventObject = _step.value;

        if (!hits.has(eventObject.id)) {
          var _ObjectsState$get2;

          (_ObjectsState$get2 = ObjectsState.get(interactions, eventObject, 'onBlur')) == null ? void 0 : _ObjectsState$get2.forEach(function (handler) {
            return handler({
              controller: it
            });
          });
          hovering["delete"](eventObject);
        }
      }
    });
  });

  var triggerEvent = function triggerEvent(interaction) {
    return function (e) {
      var hovering = hoverState[e.controller.inputSource.handedness];

      for (var _iterator2 = _createForOfIteratorHelperLoose(hovering.keys()), _step2; !(_step2 = _iterator2()).done;) {
        var _ObjectsState$get3;

        var hovered = _step2.value;
        (_ObjectsState$get3 = ObjectsState.get(interactions, hovered, interaction)) == null ? void 0 : _ObjectsState$get3.forEach(function (handler) {
          return handler({
            controller: e.controller
          });
        });
      }
    };
  };

  useXREvent('select', triggerEvent('onSelect'));
  useXREvent('selectstart', triggerEvent('onSelectStart'));
  useXREvent('selectend', triggerEvent('onSelectEnd'));
  useXREvent('squeeze', triggerEvent('onSqueeze'));
  useXREvent('squeezeend', triggerEvent('onSqueezeEnd'));
  useXREvent('squeezestart', triggerEvent('onSqueezeStart'));
  var contextValue = React.useMemo(function () {
    return {
      addInteraction: addInteraction,
      removeInteraction: removeInteraction,
      hoverState: hoverState
    };
  }, [addInteraction, removeInteraction, hoverState]);
  return /*#__PURE__*/React__default['default'].createElement(InteractionsContext.Provider, {
    value: contextValue
  }, children);
}
var useInteraction = function useInteraction(ref, type, handler) {
  var _useContext = React.useContext(InteractionsContext),
      addInteraction = _useContext.addInteraction,
      removeInteraction = _useContext.removeInteraction;

  var isPresent = handler !== undefined;
  var handlerRef = React.useRef(handler);
  React.useEffect(function () {
    handlerRef.current = handler;
  }, [handler]);
  React.useEffect(function () {
    if (!isPresent) return;

    var handlerFn = function handlerFn(e) {
      // @ts-ignore
      handlerRef.current(e);
    };

    addInteraction(ref.current, type, handlerFn);
    var maybeRef = ref.current;
    return function () {
      return removeInteraction(maybeRef, type, handlerFn);
    };
  }, [type, addInteraction, removeInteraction, isPresent, ref]);
};
var Interactive = React.forwardRef(function (props, passedRef) {
  var ref = React.useRef();
  useInteraction(ref, 'onHover', props.onHover);
  useInteraction(ref, 'onBlur', props.onBlur);
  useInteraction(ref, 'onSelectStart', props.onSelectStart);
  useInteraction(ref, 'onSelectEnd', props.onSelectEnd);
  useInteraction(ref, 'onSelect', props.onSelect);
  useInteraction(ref, 'onSqueezeStart', props.onSqueezeStart);
  useInteraction(ref, 'onSqueezeEnd', props.onSqueezeEnd);
  useInteraction(ref, 'onSqueeze', props.onSqueeze);
  return /*#__PURE__*/React__default['default'].createElement("group", {
    ref: mergeRefs__default['default']([passedRef, ref])
  }, props.children);
});
function RayGrab(_ref2) {
  var children = _ref2.children;
  var grabbingController = React.useRef();
  var groupRef = React.useRef();
  var previousTransform = React.useRef(undefined);
  useXREvent('selectend', function (e) {
    if (e.controller.controller === grabbingController.current) {
      grabbingController.current = undefined;
      previousTransform.current = undefined;
    }
  });
  fiber.useFrame(function () {
    if (!grabbingController.current || !previousTransform.current || !groupRef.current) {
      return;
    }

    var controller = grabbingController.current;
    var group = groupRef.current;
    group.applyMatrix4(previousTransform.current);
    group.applyMatrix4(controller.matrixWorld);
    group.updateWorldMatrix(false, true);
    previousTransform.current = controller.matrixWorld.clone().invert();
  });
  return /*#__PURE__*/React__default['default'].createElement(Interactive, {
    ref: groupRef,
    onSelectStart: function onSelectStart(e) {
      grabbingController.current = e.controller.controller;
      previousTransform.current = e.controller.controller.matrixWorld.clone().invert();
    }
  }, children);
}

var XRContext = React__namespace.createContext({});

var useControllers = function useControllers(group) {
  var _useThree = fiber.useThree(),
      gl = _useThree.gl;

  var _React$useState = React__namespace.useState([]),
      controllers = _React$useState[0],
      setControllers = _React$useState[1];

  React__namespace.useEffect(function () {
    var ids = [0, 1];
    ids.forEach(function (id) {
      XRController.make(id, gl, function (controller) {
        group.add(controller.controller);
        group.add(controller.grip);
        group.add(controller.hand);
        setControllers(function (it) {
          return [].concat(it, [controller]);
        });
      }, function (controller) {
        group.remove(controller.controller);
        group.remove(controller.grip);
        group.remove(controller.hand);
        setControllers(function (existing) {
          return existing.filter(function (it) {
            return it !== controller;
          });
        });
      });
    });
  }, [gl, group]);
  return controllers;
};

function useHitTest(hitTestCallback) {
  var _useThree2 = fiber.useThree(),
      gl = _useThree2.gl;

  var hitTestSource = React__namespace.useRef();
  var hitTestSourceRequested = React__namespace.useRef(false);

  var _React$useState2 = React__namespace.useState(function () {
    return new three.Matrix4();
  }),
      hitMatrix = _React$useState2[0];

  fiber.useFrame(function () {
    if (!gl.xr.isPresenting) return;
    var session = gl.xr.getSession();
    if (!session) return;

    if (!hitTestSourceRequested.current) {
      session.requestReferenceSpace('viewer').then(function (referenceSpace) {
        session.requestHitTestSource({
          space: referenceSpace
        }).then(function (source) {
          hitTestSource.current = source;
        });
      });
      session.addEventListener('end', function () {
        hitTestSourceRequested.current = false;
        hitTestSource.current = undefined;
      }, {
        once: true
      });
      hitTestSourceRequested.current = true;
    }

    if (hitTestSource.current && gl.xr.isPresenting) {
      var referenceSpace = gl.xr.getReferenceSpace();

      if (referenceSpace) {
        // This raf is unnecesary, we should get XRFrame from r3f but it's not implemented yet
        session.requestAnimationFrame(function (time, frame) {
          var hitTestResults = frame.getHitTestResults(hitTestSource.current);

          if (hitTestResults.length) {
            var _hit = hitTestResults[0];

            var pose = _hit.getPose(referenceSpace);

            if (pose) {
              hitMatrix.fromArray(pose.transform.matrix);
              hitTestCallback(hitMatrix, _hit);
            }
          }
        });
      }
    }
  });
}
function XR(_ref) {
  var _ref$foveation = _ref.foveation,
      foveation = _ref$foveation === void 0 ? 0 : _ref$foveation,
      children = _ref.children;

  var _useThree3 = fiber.useThree(),
      gl = _useThree3.gl,
      camera = _useThree3.camera;

  var _React$useState3 = React__namespace.useState(function () {
    return gl.xr.isPresenting;
  }),
      isPresenting = _React$useState3[0],
      setIsPresenting = _React$useState3[1];

  var _React$useState4 = React__namespace.useState(false),
      isHandTracking = _React$useState4[0],
      setHandTracking = _React$useState4[1];

  var _React$useState5 = React__namespace.useState(function () {
    return new three.Group();
  }),
      player = _React$useState5[0];

  var controllers = useControllers(player);
  React__namespace.useEffect(function () {
    var xr = gl.xr;

    var handleSessionChange = function handleSessionChange() {
      return setIsPresenting(xr.isPresenting);
    };

    xr.addEventListener('sessionstart', handleSessionChange);
    xr.addEventListener('sessionend', handleSessionChange);
    return function () {
      xr.removeEventListener('sessionstart', handleSessionChange);
      xr.removeEventListener('sessionend', handleSessionChange);
    };
  }, [gl]);
  React__namespace.useEffect(function () {
    var xr = gl.xr;

    if (xr.setFoveation) {
      xr.setFoveation(foveation);
    }
  }, [gl, foveation]);
  React__namespace.useEffect(function () {
    var _session$inputSources;

    var session = gl.xr.getSession();

    var handleInputSourcesChange = function handleInputSourcesChange(event) {
      return setHandTracking(Object.values(event.session.inputSources).some(function (source) {
        return source.hand;
      }));
    };

    session == null ? void 0 : session.addEventListener('inputsourceschange', handleInputSourcesChange);
    setHandTracking(Object.values((_session$inputSources = session == null ? void 0 : session.inputSources) != null ? _session$inputSources : []).some(function (source) {
      return source.hand;
    }));
    return function () {
      session == null ? void 0 : session.removeEventListener('inputsourceschange', handleInputSourcesChange);
    }; // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [isPresenting]);
  var value = React__namespace.useMemo(function () {
    return {
      controllers: controllers,
      isPresenting: isPresenting,
      isHandTracking: isHandTracking,
      player: player
    };
  }, [controllers, isPresenting, isHandTracking, player]);
  return /*#__PURE__*/React__namespace.createElement(XRContext.Provider, {
    value: value
  }, /*#__PURE__*/React__namespace.createElement("primitive", {
    object: player,
    dispose: null
  }, /*#__PURE__*/React__namespace.createElement("primitive", {
    object: camera,
    dispose: null
  })), children);
}

function XRCanvas(_ref2) {
  var foveation = _ref2.foveation,
      children = _ref2.children,
      rest = _objectWithoutPropertiesLoose__default['default'](_ref2, ["foveation", "children"]);

  return /*#__PURE__*/React__namespace.createElement(fiber.Canvas, _extends__default['default']({
    vr: true
  }, rest), /*#__PURE__*/React__namespace.createElement(XR, {
    foveation: foveation
  }, /*#__PURE__*/React__namespace.createElement(InteractionManager, null, children)));
}

var createXRButton = function createXRButton(mode, gl, sessionInit) {
  var button = mode === 'AR' ? ARButton : VRButton;
  var selector = mode === 'AR' ? '#ARButton' : '#VRButton';

  if (document.querySelector(selector) === null) {
    document.body.appendChild(button.createButton(gl, sessionInit));
  }
};

function VRCanvas(_ref3) {
  var children = _ref3.children,
      sessionInit = _ref3.sessionInit,
      _onCreated = _ref3.onCreated,
      rest = _objectWithoutPropertiesLoose__default['default'](_ref3, ["children", "sessionInit", "onCreated"]);

  return /*#__PURE__*/React__namespace.createElement(XRCanvas, _extends__default['default']({
    onCreated: function onCreated(state) {
      _onCreated == null ? void 0 : _onCreated(state);
      createXRButton('VR', state.gl, sessionInit);
    }
  }, rest), children);
}
function ARCanvas(_ref4) {
  var _onCreated2 = _ref4.onCreated,
      children = _ref4.children,
      sessionInit = _ref4.sessionInit,
      rest = _objectWithoutPropertiesLoose__default['default'](_ref4, ["onCreated", "children", "sessionInit"]);

  return /*#__PURE__*/React__namespace.createElement(XRCanvas, _extends__default['default']({
    onCreated: function onCreated(state) {
      _onCreated2 == null ? void 0 : _onCreated2(state);
      createXRButton('AR', state.gl, sessionInit);
    }
  }, rest), children);
}
var useXR = function useXR() {
  var xrValue = React__namespace.useContext(XRContext);
  var interactionsValue = React__namespace.useContext(InteractionsContext);
  var contextValue = React__namespace.useMemo(function () {
    return _extends__default['default'](_extends__default['default']({}, xrValue), interactionsValue);
  }, [xrValue, interactionsValue]);
  return contextValue;
};
var useXRFrame = function useXRFrame(callback) {
  var _useThree4 = fiber.useThree(),
      gl = _useThree4.gl;

  var requestRef = React__namespace.useRef();
  var previousTimeRef = React__namespace.useRef();
  var loop = React__namespace.useCallback(function (time, xrFrame) {
    if (previousTimeRef.current !== undefined) {
      callback(time, xrFrame);
    }

    previousTimeRef.current = time;
    requestRef.current = gl.xr.getSession().requestAnimationFrame(loop);
  }, [gl.xr, callback]);
  React__namespace.useEffect(function () {
    var _gl$xr;

    if (!((_gl$xr = gl.xr) == null ? void 0 : _gl$xr.isPresenting)) {
      return;
    }

    requestRef.current = gl.xr.getSession().requestAnimationFrame(loop);
    return function () {
      if (requestRef.current) {
        gl.xr.getSession().cancelAnimationFrame(requestRef.current);
      }
    };
  }, [gl.xr.isPresenting, loop, gl.xr]);
};
var useController = function useController(handedness) {
  var _useXR = useXR(),
      controllers = _useXR.controllers;

  var controller = React__namespace.useMemo(function () {
    return controllers.find(function (it) {
      return it.inputSource.handedness === handedness;
    });
  }, [handedness, controllers]);
  return controller;
};

var DEFAULT_PROFILES_PATH = 'https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets@1.0/dist/profiles';
var DEFAULT_PROFILE = 'generic-trigger';

var XRControllerModel = /*#__PURE__*/function (_Object3D) {
  _inheritsLoose__default['default'](XRControllerModel, _Object3D);

  function XRControllerModel() {
    var _this;

    _this = _Object3D.call(this) || this;
    _this.motionController = null;
    _this.envMap = null;
    return _this;
  }

  var _proto = XRControllerModel.prototype;

  _proto.setEnvironmentMap = function setEnvironmentMap(envMap) {
    var _this2 = this;

    if (this.envMap == envMap) {
      return this;
    }

    this.envMap = envMap;
    this.traverse(function (child) {
      if (child.isMesh) {
        child.material.envMap = _this2.envMap;
        child.material.needsUpdate = true;
      }
    });
    return this;
  }
  /**
   * Polls data from the XRInputSource and updates the model's components to match
   * the real world data
   */
  ;

  _proto.updateMatrixWorld = function updateMatrixWorld(force) {
    _Object3D.prototype.updateMatrixWorld.call(this, force);

    if (!this.motionController) return; // Cause the MotionController to poll the Gamepad for data

    this.motionController.updateFromGamepad(); // Update the 3D model to reflect the button, thumbstick, and touchpad state

    Object.values(this.motionController.components).forEach(function (component) {
      // Update node data based on the visual responses' current states
      Object.values(component.visualResponses).forEach(function (visualResponse) {
        var valueNode = visualResponse.valueNode,
            minNode = visualResponse.minNode,
            maxNode = visualResponse.maxNode,
            value = visualResponse.value,
            valueNodeProperty = visualResponse.valueNodeProperty; // Skip if the visual response node is not found. No error is needed,
        // because it will have been reported at load time.

        if (!valueNode) return; // Calculate the new properties based on the weight supplied

        if (valueNodeProperty === motionControllers.Constants.VisualResponseProperty.VISIBILITY) {
          valueNode.visible = value;
        } else if (valueNodeProperty === motionControllers.Constants.VisualResponseProperty.TRANSFORM) {
          valueNode.quaternion.slerpQuaternions(minNode.quaternion, maxNode.quaternion, value);
          valueNode.position.lerpVectors(minNode.position, maxNode.position, value);
        }
      });
    });
  };

  return XRControllerModel;
}(three.Object3D);
/**
 * Walks the model's tree to find the nodes needed to animate the components and
 * saves them to the motionContoller components for use in the frame loop. When
 * touchpads are found, attaches a touch dot to them.
 */


function findNodes(motionController, scene) {
  // Loop through the components and find the nodes needed for each components' visual responses
  Object.values(motionController.components).forEach(function (component) {
    var type = component.type,
        touchPointNodeName = component.touchPointNodeName,
        visualResponses = component.visualResponses;

    if (type === motionControllers.Constants.ComponentType.TOUCHPAD) {
      component.touchPointNode = scene.getObjectByName(touchPointNodeName);

      if (component.touchPointNode) {
        // Attach a touch dot to the touchpad.
        var sphereGeometry = new three.SphereGeometry(0.001);
        var material = new three.MeshBasicMaterial({
          color: 0x0000ff
        });
        var sphere = new three.Mesh(sphereGeometry, material);
        component.touchPointNode.add(sphere);
      } else {
        console.warn("Could not find touch dot, " + component.touchPointNodeName + ", in touchpad component " + component.id);
      }
    } // Loop through all the visual responses to be applied to this component


    Object.values(visualResponses).forEach(function (visualResponse) {
      var valueNodeName = visualResponse.valueNodeName,
          minNodeName = visualResponse.minNodeName,
          maxNodeName = visualResponse.maxNodeName,
          valueNodeProperty = visualResponse.valueNodeProperty; // If animating a transform, find the two nodes to be interpolated between.

      if (valueNodeProperty === motionControllers.Constants.VisualResponseProperty.TRANSFORM) {
        visualResponse.minNode = scene.getObjectByName(minNodeName);
        visualResponse.maxNode = scene.getObjectByName(maxNodeName); // If the extents cannot be found, skip this animation

        if (!visualResponse.minNode) {
          console.warn("Could not find " + minNodeName + " in the model");
          return;
        }

        if (!visualResponse.maxNode) {
          console.warn("Could not find " + maxNodeName + " in the model");
          return;
        }
      } // If the target node cannot be found, skip this animation


      visualResponse.valueNode = scene.getObjectByName(valueNodeName);

      if (!visualResponse.valueNode) {
        console.warn("Could not find " + valueNodeName + " in the model");
      }
    });
  });
}

function addAssetSceneToControllerModel(controllerModel, scene) {
  // Find the nodes needed for animation and cache them on the motionController.
  findNodes(controllerModel.motionController, scene); // Apply any environment map that the mesh already has set.

  if (controllerModel.envMap) {
    scene.traverse(function (child) {
      if (child.isMesh) {
        child.material.envMap = controllerModel.envMap;
        child.material.needsUpdate = true;
      }
    });
  } // Add the glTF scene to the controllerModel.


  controllerModel.add(scene);
}

var XRControllerModelFactory = /*#__PURE__*/function () {
  function XRControllerModelFactory(gltfLoader) {
    if (gltfLoader === void 0) {
      gltfLoader = null;
    }

    this.gltfLoader = gltfLoader;
    this.path = DEFAULT_PROFILES_PATH;
    this._assetCache = {}; // If a GLTFLoader wasn't supplied to the constructor create a new one.

    if (!this.gltfLoader) {
      this.gltfLoader = new GLTFLoader.GLTFLoader();
    }
  }

  var _proto2 = XRControllerModelFactory.prototype;

  _proto2.createControllerModel = function createControllerModel(controller) {
    var _this3 = this;

    var controllerModel = new XRControllerModel();
    var scene = null;
    controller.addEventListener('connected', function (event) {
      var xrInputSource = event.data;
      if (xrInputSource.targetRayMode !== 'tracked-pointer' || !xrInputSource.gamepad) return;
      motionControllers.fetchProfile(xrInputSource, _this3.path, DEFAULT_PROFILE).then(function (_ref) {
        var profile = _ref.profile,
            assetPath = _ref.assetPath;
        controllerModel.motionController = new motionControllers.MotionController(xrInputSource, profile, assetPath);
        var cachedAsset = _this3._assetCache[controllerModel.motionController.assetUrl];

        if (cachedAsset) {
          scene = cachedAsset.scene.clone();
          addAssetSceneToControllerModel(controllerModel, scene);
        } else {
          if (!_this3.gltfLoader) {
            throw new Error('GLTFLoader not set.');
          }

          _this3.gltfLoader.setPath('');

          _this3.gltfLoader.load(controllerModel.motionController.assetUrl, function (asset) {
            _this3._assetCache[controllerModel.motionController.assetUrl] = asset;
            scene = asset.scene.clone();
            addAssetSceneToControllerModel(controllerModel, scene);
          }, null, function () {
            throw new Error("Asset " + controllerModel.motionController.assetUrl + " missing or malformed.");
          });
        }
      })["catch"](function (err) {
        console.warn(err);
      });
    });
    controller.addEventListener('disconnected', function () {
      controllerModel.motionController = null;
      controllerModel.remove(scene);
      scene = null;
    });
    return controllerModel;
  };

  return XRControllerModelFactory;
}();

var modelFactory = new XRControllerModelFactory();
var modelCache = new WeakMap();
function DefaultXRControllers(_ref) {
  var _ref$rayMaterial = _ref.rayMaterial,
      rayMaterial = _ref$rayMaterial === void 0 ? {} : _ref$rayMaterial;

  var _useThree = fiber.useThree(),
      scene = _useThree.scene;

  var _useXR = useXR(),
      controllers = _useXR.controllers,
      hoverState = _useXR.hoverState;

  var _React$useState = React__default['default'].useState(new Map()),
      rays = _React$useState[0]; // Show ray line when hovering objects


  fiber.useFrame(function () {
    controllers.forEach(function (it) {
      var ray = rays.get(it.controller.id);
      if (!ray) return;
      var intersection = hoverState[it.inputSource.handedness].values().next().value;

      if (!intersection || it.inputSource.handedness === 'none') {
        ray.visible = false;
        return;
      }

      var rayLength = intersection.distance; // Tiny offset to clip ray on AR devices
      // that don't have handedness set to 'none'

      var offset = -0.01;
      ray.visible = true;
      ray.scale.y = rayLength + offset;
      ray.position.z = -rayLength / 2 - offset;
    });
  });
  React.useEffect(function () {
    var cleanups = [];
    controllers.forEach(function (_ref2) {
      var controller = _ref2.controller,
          grip = _ref2.grip,
          inputSource = _ref2.inputSource;
      // Attach 3D model of the controller
      var model;

      if (modelCache.has(controller)) {
        model = modelCache.get(controller);
      } else {
        model = modelFactory.createControllerModel(controller);
        controller.dispatchEvent({
          type: 'connected',
          data: inputSource,
          fake: true
        });
        modelCache.set(controller, model);
      }

      grip.add(model); // Add Ray line (used for hovering)

      var ray = new three.Mesh();
      ray.rotation.set(Math.PI / 2, 0, 0);
      ray.material = new three.MeshBasicMaterial(_extends__default['default']({
        color: new three.Color(0xffffff),
        opacity: 0.8,
        transparent: true
      }, rayMaterial));
      ray.geometry = new three.BoxBufferGeometry(0.002, 1, 0.002);
      rays.set(controller.id, ray);
      controller.add(ray);
      cleanups.push(function () {
        grip.remove(model);
        controller.remove(ray);
        rays["delete"](controller.id);
      });
    });
    return function () {
      cleanups.forEach(function (fn) {
        return fn();
      });
    }; // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [controllers, scene, rays, JSON.stringify(rayMaterial)]);
  return null;
}

var DEFAULT_HAND_PROFILE_PATH = 'https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets@1.0/dist/profiles/generic-hand/';

var XRHandMeshModel = /*#__PURE__*/function () {
  function XRHandMeshModel(handModel, controller, path, handedness, customModel) {
    var _this = this;

    this.controller = controller;
    this.handModel = handModel;
    this.bones = [];
    var loader = new GLTFLoader.GLTFLoader();
    if (!customModel) loader.setPath(path || DEFAULT_HAND_PROFILE_PATH);
    loader.load(customModel != null ? customModel : handedness + ".glb", function (gltf) {
      var object = gltf.scene.children[0];

      _this.handModel.add(object);

      var mesh = object.getObjectByProperty('type', 'SkinnedMesh');
      mesh.frustumCulled = false;
      mesh.castShadow = true;
      mesh.receiveShadow = true;
      mesh.material.side = 0; // Workaround: force FrontSide

      var joints = ['wrist', 'thumb-metacarpal', 'thumb-phalanx-proximal', 'thumb-phalanx-distal', 'thumb-tip', 'index-finger-metacarpal', 'index-finger-phalanx-proximal', 'index-finger-phalanx-intermediate', 'index-finger-phalanx-distal', 'index-finger-tip', 'middle-finger-metacarpal', 'middle-finger-phalanx-proximal', 'middle-finger-phalanx-intermediate', 'middle-finger-phalanx-distal', 'middle-finger-tip', 'ring-finger-metacarpal', 'ring-finger-phalanx-proximal', 'ring-finger-phalanx-intermediate', 'ring-finger-phalanx-distal', 'ring-finger-tip', 'pinky-finger-metacarpal', 'pinky-finger-phalanx-proximal', 'pinky-finger-phalanx-intermediate', 'pinky-finger-phalanx-distal', 'pinky-finger-tip'];
      joints.forEach(function (jointName) {
        var bone = object.getObjectByName(jointName);

        if (bone !== undefined) {
          bone.jointName = jointName;
        } else {
          console.warn("Couldn't find " + jointName + " in " + handedness + " hand mesh");
        }

        _this.bones.push(bone);
      });
    });
  }

  var _proto = XRHandMeshModel.prototype;

  _proto.updateMesh = function updateMesh() {
    // XR Joints
    var XRJoints = this.controller.joints;

    for (var i = 0; i < this.bones.length; i++) {
      var bone = this.bones[i];

      if (bone) {
        var XRJoint = XRJoints[bone.jointName];

        if (XRJoint.visible) {
          var position = XRJoint.position;

          if (bone) {
            bone.position.copy(position);
            bone.quaternion.copy(XRJoint.quaternion); // bone.scale.setScalar( XRJoint.jointRadius || defaultRadius );
          }
        }
      }
    }
  };

  return XRHandMeshModel;
}();

var TOUCH_RADIUS = 0.01;
var POINTING_JOINT = 'index-finger-tip';

var HandModel = /*#__PURE__*/function (_Object3D) {
  _inheritsLoose__default['default'](HandModel, _Object3D);

  function HandModel(controller, customModels) {
    var _this;

    _this = _Object3D.call(this) || this;
    _this.controller = controller;
    _this.motionController = null;
    _this.envMap = null;
    _this.mesh = null;
    controller.addEventListener('connected', function (event) {
      var xrInputSource = event.data;

      if (xrInputSource.hand && !_this.motionController) {
        _this.xrInputSource = xrInputSource;
        _this.motionController = new XRHandMeshModel(_assertThisInitialized__default['default'](_this), controller, _this.path, xrInputSource.handedness, xrInputSource.handedness === "left" ? customModels[0] : customModels[1]);
      }
    });
    controller.addEventListener('disconnected', function () {
      _this.clear();

      _this.motionController = null;
    });
    return _this;
  }

  var _proto = HandModel.prototype;

  _proto.updateMatrixWorld = function updateMatrixWorld(force) {
    _Object3D.prototype.updateMatrixWorld.call(this, force);

    if (this.motionController) {
      this.motionController.updateMesh();
    }
  };

  _proto.getPointerPosition = function getPointerPosition() {
    var indexFingerTip = this.controller.joints[POINTING_JOINT];

    if (indexFingerTip) {
      return indexFingerTip.position;
    } else {
      return null;
    }
  };

  _proto.intersectBoxObject = function intersectBoxObject(boxObject) {
    var pointerPosition = this.getPointerPosition();

    if (pointerPosition) {
      var indexSphere = new three.Sphere(pointerPosition, TOUCH_RADIUS);
      var box = new three.Box3().setFromObject(boxObject);
      return indexSphere.intersectsBox(box);
    } else {
      return false;
    }
  };

  _proto.checkButton = function checkButton(button) {
    if (this.intersectBoxObject(button)) {
      button.onPress();
    } else {
      button.onClear();
    }

    if (button.isPressed()) {
      button.whilePressed();
    }
  };

  return HandModel;
}(three.Object3D);

function Hands(props) {
  var _useThree = fiber.useThree(),
      scene = _useThree.scene,
      gl = _useThree.gl;

  var _useXR = useXR(),
      controllers = _useXR.controllers;

  React.useEffect(function () {
    controllers.forEach(function (_ref) {
      var hand = _ref.hand,
          inputSource = _ref.inputSource;
      var handModel = hand.children.find(function (child) {
        return child instanceof HandModel;
      });

      if (handModel === undefined) {
        hand.add(new HandModel(hand, [props.modelLeft, props.modelRight])); // throwing fake event for the Oculus Hand Model so it starts loading

        hand.dispatchEvent({
          type: 'connected',
          data: inputSource,
          fake: true
        });
      }
    });
  }, [scene, gl, controllers]);
  return null;
}

exports.ARCanvas = ARCanvas;
exports.DefaultXRControllers = DefaultXRControllers;
exports.Hands = Hands;
exports.InteractionManager = InteractionManager;
exports.InteractionsContext = InteractionsContext;
exports.Interactive = Interactive;
exports.RayGrab = RayGrab;
exports.VRCanvas = VRCanvas;
exports.XR = XR;
exports.XRController = XRController;
exports.useController = useController;
exports.useHitTest = useHitTest;
exports.useInteraction = useInteraction;
exports.useXR = useXR;
exports.useXREvent = useXREvent;
exports.useXRFrame = useXRFrame;
