import _extends from '@babel/runtime/helpers/esm/extends';
import * as React from 'react';
import React__default, { useMemo, useContext, useRef, useEffect, forwardRef } from 'react';
import { useFrame, useThree, Canvas } from '@react-three/fiber';
import { Raycaster, Matrix4, Group, Object3D, SphereGeometry, MeshBasicMaterial, Mesh, Color, BoxBufferGeometry, Sphere, Box3 } from 'three';
import mergeRefs from 'react-merge-refs';
import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader';
import { fetchProfile, MotionController, Constants } from '@webxr-input-profiles/motion-controllers';

class ARButton {
  static createButton(renderer, sessionInit = {}) {
    const button = document.createElement('button');

    function showStartAR()
    /*device*/
    {
      if (sessionInit.domOverlay === undefined) {
        const overlay = document.createElement('div');
        overlay.style.display = 'none';
        document.body.appendChild(overlay);
        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        svg.setAttribute('width', 38);
        svg.setAttribute('height', 38);
        svg.style.position = 'absolute';
        svg.style.right = '20px';
        svg.style.top = '20px';
        svg.addEventListener('click', function () {
          currentSession.end();
        });
        overlay.appendChild(svg);
        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        path.setAttribute('d', 'M 12,12 L 28,28 M 28,12 12,28');
        path.setAttribute('stroke', '#fff');
        path.setAttribute('stroke-width', 2);
        svg.appendChild(path);

        if (sessionInit.optionalFeatures === undefined) {
          sessionInit.optionalFeatures = [];
        }

        sessionInit.optionalFeatures.push('dom-overlay');
        sessionInit.domOverlay = {
          root: overlay
        };
      } //


      let currentSession = null;

      async function onSessionStarted(session) {
        session.addEventListener('end', onSessionEnded);
        renderer.xr.setReferenceSpaceType('local');
        await renderer.xr.setSession(session);
        button.textContent = 'STOP AR';
        sessionInit.domOverlay.root.style.display = '';
        currentSession = session;
      }

      function onSessionEnded()
      /*event*/
      {
        currentSession.removeEventListener('end', onSessionEnded);
        button.textContent = 'START AR';
        sessionInit.domOverlay.root.style.display = 'none';
        currentSession = null;
      } //


      button.style.display = '';
      button.style.cursor = 'pointer';
      button.style.left = 'calc(50% - 50px)';
      button.style.width = '100px';
      button.textContent = 'START AR';

      button.onmouseenter = function () {
        button.style.opacity = '1.0';
      };

      button.onmouseleave = function () {
        button.style.opacity = '0.5';
      };

      button.onclick = function () {
        if (currentSession === null) {
          navigator.xr.requestSession('immersive-ar', sessionInit).then(onSessionStarted);
        } else {
          currentSession.end();
        }
      };
    }

    function disableButton() {
      button.style.display = '';
      button.style.cursor = 'auto';
      button.style.left = 'calc(50% - 75px)';
      button.style.width = '150px';
      button.onmouseenter = null;
      button.onmouseleave = null;
      button.onclick = null;
    }

    function showARNotSupported() {
      disableButton();
      button.textContent = 'AR NOT SUPPORTED';
    }

    function stylizeElement(element) {
      element.style.position = 'absolute';
      element.style.bottom = '20px';
      element.style.padding = '12px 6px';
      element.style.border = '1px solid #fff';
      element.style.borderRadius = '4px';
      element.style.background = 'rgba(0,0,0,0.1)';
      element.style.color = '#fff';
      element.style.font = 'normal 13px sans-serif';
      element.style.textAlign = 'center';
      element.style.opacity = '0.5';
      element.style.outline = 'none';
      element.style.zIndex = '999';
    }

    if ('xr' in navigator) {
      button.id = 'ARButton';
      button.style.display = 'none';
      stylizeElement(button);
      navigator.xr.isSessionSupported('immersive-ar').then(function (supported) {
        supported ? showStartAR() : showARNotSupported();
      }).catch(showARNotSupported);
      return button;
    } else {
      const message = document.createElement('a');

      if (window.isSecureContext === false) {
        message.href = document.location.href.replace(/^http:/, 'https:');
        message.innerHTML = 'WEBXR NEEDS HTTPS'; // TODO Improve message
      } else {
        message.href = 'https://immersiveweb.dev/';
        message.innerHTML = 'WEBXR NOT AVAILABLE';
      }

      message.style.left = 'calc(50% - 90px)';
      message.style.width = '180px';
      message.style.textDecoration = 'none';
      stylizeElement(message);
      return message;
    }
  }

}

class VRButton {
  static createButton(renderer, sessionInit = {}) {
    const button = document.createElement('button');

    function showEnterVR()
    /*device*/
    {
      let currentSession = null;

      async function onSessionStarted(session) {
        session.addEventListener('end', onSessionEnded);
        await renderer.xr.setSession(session);
        button.textContent = 'EXIT VR';
        currentSession = session;
      }

      function onSessionEnded()
      /*event*/
      {
        currentSession.removeEventListener('end', onSessionEnded);
        button.textContent = 'ENTER VR';
        currentSession = null;
      } //


      button.style.display = '';
      button.style.cursor = 'pointer';
      button.style.left = 'calc(50% - 50px)';
      button.style.width = '100px';
      button.textContent = 'ENTER VR';

      button.onmouseenter = function () {
        button.style.opacity = '1.0';
      };

      button.onmouseleave = function () {
        button.style.opacity = '0.5';
      };

      button.onclick = function () {
        if (currentSession === null) {
          // WebXR's requestReferenceSpace only works if the corresponding feature
          // was requested at session creation time. For simplicity, just ask for
          // the interesting ones as optional features, but be aware that the
          // requestReferenceSpace call will fail if it turns out to be unavailable.
          // ('local' is always available for immersive sessions and doesn't need to
          // be requested separately.)
          const optionalFeatures = [sessionInit.optionalFeatures, 'local-floor', 'bounded-floor', 'hand-tracking'].flat().filter(Boolean);
          sessionInit.optionalFeatures = navigator.xr.requestSession('immersive-vr', { ...sessionInit,
            optionalFeatures
          }).then(onSessionStarted);
        } else {
          currentSession.end();
        }
      };
    }

    function disableButton() {
      button.style.display = '';
      button.style.cursor = 'auto';
      button.style.left = 'calc(50% - 75px)';
      button.style.width = '150px';
      button.onmouseenter = null;
      button.onmouseleave = null;
      button.onclick = null;
    }

    function showWebXRNotFound() {
      disableButton();
      button.textContent = 'VR NOT SUPPORTED';
    }

    function stylizeElement(element) {
      element.style.position = 'absolute';
      element.style.bottom = '20px';
      element.style.padding = '12px 6px';
      element.style.border = '1px solid #fff';
      element.style.borderRadius = '4px';
      element.style.background = 'rgba(0,0,0,0.1)';
      element.style.color = '#fff';
      element.style.font = 'normal 13px sans-serif';
      element.style.textAlign = 'center';
      element.style.opacity = '0.5';
      element.style.outline = 'none';
      element.style.zIndex = '999';
    }

    if ('xr' in navigator) {
      button.id = 'VRButton';
      button.style.display = 'none';
      stylizeElement(button);
      navigator.xr.isSessionSupported('immersive-vr').then(function (supported) {
        supported ? showEnterVR() : showWebXRNotFound();
      });
      return button;
    } else {
      const message = document.createElement('a');

      if (window.isSecureContext === false) {
        message.href = document.location.href.replace(/^http:/, 'https:');
        message.innerHTML = 'WEBXR NEEDS HTTPS'; // TODO Improve message
      } else {
        message.href = 'https://immersiveweb.dev/';
        message.innerHTML = 'WEBXR NOT AVAILABLE';
      }

      message.style.left = 'calc(50% - 90px)';
      message.style.width = '180px';
      message.style.textDecoration = 'none';
      stylizeElement(message);
      return message;
    }
  }

}

const XRController = {
  make: (id, gl, onConnected, onDisconnected) => {
    const controller = gl.xr.getController(id);
    const grip = gl.xr.getControllerGrip(id);
    const hand = gl.xr.getHand(id);
    const xrController = {
      inputSource: undefined,
      grip,
      controller,
      hand
    };
    grip.userData.name = 'grip';
    controller.userData.name = 'controller';
    hand.userData.name = 'hand';
    controller.addEventListener('connected', event => {
      if (event.fake) {
        return;
      }

      xrController.inputSource = event.data;
      onConnected(xrController);
    });
    controller.addEventListener('disconnected', _ => {
      onDisconnected(xrController);
    });
  }
};

/**
 * Store data associated with some objects in the scene
 *
 * For example storing event handlers:
 *
 * objectA:
 *   onClick: [handler, handler]
 * objectB:
 *   onHover: [handler]
 *   onBlur:  [handler]
 *
 */
const ObjectsState = {
  make: function () {
    return new Map();
  },
  add: function (state, object, key, value) {
    if (!state.has(object)) {
      state.set(object, {
        key: [value]
      });
    }

    const entry = state.get(object);

    if (!entry[key]) {
      entry[key] = [];
    }

    entry[key].push(value);
  },
  delete: function (state, object, key, value) {
    const entry = state.get(object);
    if (!entry || !entry[key]) return;
    entry[key] = entry[key].filter(it => it !== value);

    if (entry[key].length === 0) {
      delete entry[key];
    } // Remove entry if nothing left


    if (Object.keys(entry).length === 0) {
      state.delete(object);
    }
  },
  has: function (state, object, key) {
    const entry = state.get(object);
    return !!(entry && entry[key]);
  },
  get: function (state, object, key) {
    const entry = state.get(object);
    return entry && entry[key];
  }
};

const useXREvent = (event, handler, {
  handedness
} = {}) => {
  const handlerRef = React__default.useRef(handler);
  React__default.useEffect(() => {
    handlerRef.current = handler;
  }, [handler]);
  const {
    controllers: allControllers
  } = useXR();
  React__default.useEffect(() => {
    const controllers = handedness ? allControllers.filter(it => it.inputSource.handedness === handedness) : allControllers;
    const cleanups = [];
    controllers.forEach(it => {
      const listener = e => handlerRef.current({
        originalEvent: e,
        controller: it
      });

      it.controller.addEventListener(event, listener);
      cleanups.push(() => it.controller.removeEventListener(event, listener));
    });
    return () => cleanups.forEach(fn => fn());
  }, [event, allControllers, handedness]);
};

const InteractionsContext = React__default.createContext({});
function InteractionManager({
  children
}) {
  const {
    controllers
  } = useXR();
  const [hoverState] = React__default.useState(() => ({
    left: new Map(),
    right: new Map(),
    none: new Map()
  }));
  const [interactions] = React__default.useState(() => ObjectsState.make());
  const addInteraction = React__default.useCallback((object, eventType, handler) => {
    ObjectsState.add(interactions, object, eventType, handler);
  }, [interactions]);
  const removeInteraction = React__default.useCallback((object, eventType, handler) => {
    ObjectsState.delete(interactions, object, eventType, handler);
  }, [interactions]);
  const [raycaster] = React__default.useState(() => new Raycaster());
  const intersect = React__default.useCallback(controller => {
    const objects = Array.from(interactions.keys());
    const tempMatrix = new Matrix4();
    tempMatrix.identity().extractRotation(controller.matrixWorld);
    raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
    raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);
    return raycaster.intersectObjects(objects, true);
  }, [interactions, raycaster]); // Trigger hover and blur events

  useFrame(() => {
    if (interactions.size === 0) {
      return;
    }

    controllers.forEach(it => {
      const {
        controller
      } = it;
      const handedness = it.inputSource.handedness;
      const hovering = hoverState[handedness];
      const hits = new Set();
      const intersections = intersect(controller);
      intersections.forEach(intersection => {
        let eventObject = intersection.object;

        while (eventObject) {
          if (ObjectsState.has(interactions, eventObject, 'onHover') && !hovering.has(eventObject)) {
            var _ObjectsState$get;

            (_ObjectsState$get = ObjectsState.get(interactions, eventObject, 'onHover')) == null ? void 0 : _ObjectsState$get.forEach(handler => handler({
              controller: it,
              intersection
            }));
          }

          hovering.set(eventObject, intersection);
          hits.add(eventObject.id);
          eventObject = eventObject.parent;
        }
      }); // Trigger blur on all the object that were hovered in the previous frame
      // but missed in this one

      for (const eventObject of hovering.keys()) {
        if (!hits.has(eventObject.id)) {
          var _ObjectsState$get2;

          (_ObjectsState$get2 = ObjectsState.get(interactions, eventObject, 'onBlur')) == null ? void 0 : _ObjectsState$get2.forEach(handler => handler({
            controller: it
          }));
          hovering.delete(eventObject);
        }
      }
    });
  });

  const triggerEvent = interaction => e => {
    const hovering = hoverState[e.controller.inputSource.handedness];

    for (const hovered of hovering.keys()) {
      var _ObjectsState$get3;

      (_ObjectsState$get3 = ObjectsState.get(interactions, hovered, interaction)) == null ? void 0 : _ObjectsState$get3.forEach(handler => handler({
        controller: e.controller
      }));
    }
  };

  useXREvent('select', triggerEvent('onSelect'));
  useXREvent('selectstart', triggerEvent('onSelectStart'));
  useXREvent('selectend', triggerEvent('onSelectEnd'));
  useXREvent('squeeze', triggerEvent('onSqueeze'));
  useXREvent('squeezeend', triggerEvent('onSqueezeEnd'));
  useXREvent('squeezestart', triggerEvent('onSqueezeStart'));
  const contextValue = useMemo(() => ({
    addInteraction,
    removeInteraction,
    hoverState
  }), [addInteraction, removeInteraction, hoverState]);
  return /*#__PURE__*/React__default.createElement(InteractionsContext.Provider, {
    value: contextValue
  }, children);
}
const useInteraction = (ref, type, handler) => {
  const {
    addInteraction,
    removeInteraction
  } = useContext(InteractionsContext);
  const isPresent = handler !== undefined;
  const handlerRef = useRef(handler);
  useEffect(() => {
    handlerRef.current = handler;
  }, [handler]);
  useEffect(() => {
    if (!isPresent) return;

    const handlerFn = e => {
      // @ts-ignore
      handlerRef.current(e);
    };

    addInteraction(ref.current, type, handlerFn);
    const maybeRef = ref.current;
    return () => removeInteraction(maybeRef, type, handlerFn);
  }, [type, addInteraction, removeInteraction, isPresent, ref]);
};
const Interactive = forwardRef((props, passedRef) => {
  const ref = useRef();
  useInteraction(ref, 'onHover', props.onHover);
  useInteraction(ref, 'onBlur', props.onBlur);
  useInteraction(ref, 'onSelectStart', props.onSelectStart);
  useInteraction(ref, 'onSelectEnd', props.onSelectEnd);
  useInteraction(ref, 'onSelect', props.onSelect);
  useInteraction(ref, 'onSqueezeStart', props.onSqueezeStart);
  useInteraction(ref, 'onSqueezeEnd', props.onSqueezeEnd);
  useInteraction(ref, 'onSqueeze', props.onSqueeze);
  return /*#__PURE__*/React__default.createElement("group", {
    ref: mergeRefs([passedRef, ref])
  }, props.children);
});
function RayGrab({
  children
}) {
  const grabbingController = useRef();
  const groupRef = useRef();
  const previousTransform = useRef(undefined);
  useXREvent('selectend', e => {
    if (e.controller.controller === grabbingController.current) {
      grabbingController.current = undefined;
      previousTransform.current = undefined;
    }
  });
  useFrame(() => {
    if (!grabbingController.current || !previousTransform.current || !groupRef.current) {
      return;
    }

    const controller = grabbingController.current;
    const group = groupRef.current;
    group.applyMatrix4(previousTransform.current);
    group.applyMatrix4(controller.matrixWorld);
    group.updateWorldMatrix(false, true);
    previousTransform.current = controller.matrixWorld.clone().invert();
  });
  return /*#__PURE__*/React__default.createElement(Interactive, {
    ref: groupRef,
    onSelectStart: e => {
      grabbingController.current = e.controller.controller;
      previousTransform.current = e.controller.controller.matrixWorld.clone().invert();
    }
  }, children);
}

const XRContext = React.createContext({});

const useControllers = group => {
  const {
    gl
  } = useThree();
  const [controllers, setControllers] = React.useState([]);
  React.useEffect(() => {
    const ids = [0, 1];
    ids.forEach(id => {
      XRController.make(id, gl, controller => {
        group.add(controller.controller);
        group.add(controller.grip);
        group.add(controller.hand);
        setControllers(it => [...it, controller]);
      }, controller => {
        group.remove(controller.controller);
        group.remove(controller.grip);
        group.remove(controller.hand);
        setControllers(existing => existing.filter(it => it !== controller));
      });
    });
  }, [gl, group]);
  return controllers;
};

function useHitTest(hitTestCallback) {
  const {
    gl
  } = useThree();
  const hitTestSource = React.useRef();
  const hitTestSourceRequested = React.useRef(false);
  const [hitMatrix] = React.useState(() => new Matrix4());
  useFrame(() => {
    if (!gl.xr.isPresenting) return;
    const session = gl.xr.getSession();
    if (!session) return;

    if (!hitTestSourceRequested.current) {
      session.requestReferenceSpace('viewer').then(referenceSpace => {
        session.requestHitTestSource({
          space: referenceSpace
        }).then(source => {
          hitTestSource.current = source;
        });
      });
      session.addEventListener('end', () => {
        hitTestSourceRequested.current = false;
        hitTestSource.current = undefined;
      }, {
        once: true
      });
      hitTestSourceRequested.current = true;
    }

    if (hitTestSource.current && gl.xr.isPresenting) {
      const referenceSpace = gl.xr.getReferenceSpace();

      if (referenceSpace) {
        // This raf is unnecesary, we should get XRFrame from r3f but it's not implemented yet
        session.requestAnimationFrame((time, frame) => {
          const hitTestResults = frame.getHitTestResults(hitTestSource.current);

          if (hitTestResults.length) {
            const hit = hitTestResults[0];
            const pose = hit.getPose(referenceSpace);

            if (pose) {
              hitMatrix.fromArray(pose.transform.matrix);
              hitTestCallback(hitMatrix, hit);
            }
          }
        });
      }
    }
  });
}
function XR({
  foveation = 0,
  children
}) {
  const {
    gl,
    camera
  } = useThree();
  const [isPresenting, setIsPresenting] = React.useState(() => gl.xr.isPresenting);
  const [isHandTracking, setHandTracking] = React.useState(false);
  const [player] = React.useState(() => new Group());
  const controllers = useControllers(player);
  React.useEffect(() => {
    const xr = gl.xr;

    const handleSessionChange = () => setIsPresenting(xr.isPresenting);

    xr.addEventListener('sessionstart', handleSessionChange);
    xr.addEventListener('sessionend', handleSessionChange);
    return () => {
      xr.removeEventListener('sessionstart', handleSessionChange);
      xr.removeEventListener('sessionend', handleSessionChange);
    };
  }, [gl]);
  React.useEffect(() => {
    const xr = gl.xr;

    if (xr.setFoveation) {
      xr.setFoveation(foveation);
    }
  }, [gl, foveation]);
  React.useEffect(() => {
    var _session$inputSources;

    const session = gl.xr.getSession();

    const handleInputSourcesChange = event => setHandTracking(Object.values(event.session.inputSources).some(source => source.hand));

    session == null ? void 0 : session.addEventListener('inputsourceschange', handleInputSourcesChange);
    setHandTracking(Object.values((_session$inputSources = session == null ? void 0 : session.inputSources) != null ? _session$inputSources : []).some(source => source.hand));
    return () => {
      session == null ? void 0 : session.removeEventListener('inputsourceschange', handleInputSourcesChange);
    }; // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [isPresenting]);
  const value = React.useMemo(() => ({
    controllers,
    isPresenting,
    isHandTracking,
    player
  }), [controllers, isPresenting, isHandTracking, player]);
  return /*#__PURE__*/React.createElement(XRContext.Provider, {
    value: value
  }, /*#__PURE__*/React.createElement("primitive", {
    object: player,
    dispose: null
  }, /*#__PURE__*/React.createElement("primitive", {
    object: camera,
    dispose: null
  })), children);
}

function XRCanvas({
  foveation,
  children,
  ...rest
}) {
  return /*#__PURE__*/React.createElement(Canvas, _extends({
    vr: true
  }, rest), /*#__PURE__*/React.createElement(XR, {
    foveation: foveation
  }, /*#__PURE__*/React.createElement(InteractionManager, null, children)));
}

const createXRButton = (mode, gl, sessionInit) => {
  const button = mode === 'AR' ? ARButton : VRButton;
  const selector = mode === 'AR' ? '#ARButton' : '#VRButton';

  if (document.querySelector(selector) === null) {
    document.body.appendChild(button.createButton(gl, sessionInit));
  }
};

function VRCanvas({
  children,
  sessionInit,
  onCreated,
  ...rest
}) {
  return /*#__PURE__*/React.createElement(XRCanvas, _extends({
    onCreated: state => {
      onCreated == null ? void 0 : onCreated(state);
      createXRButton('VR', state.gl, sessionInit);
    }
  }, rest), children);
}
function ARCanvas({
  onCreated,
  children,
  sessionInit,
  ...rest
}) {
  return /*#__PURE__*/React.createElement(XRCanvas, _extends({
    onCreated: state => {
      onCreated == null ? void 0 : onCreated(state);
      createXRButton('AR', state.gl, sessionInit);
    }
  }, rest), children);
}
const useXR = () => {
  const xrValue = React.useContext(XRContext);
  const interactionsValue = React.useContext(InteractionsContext);
  const contextValue = React.useMemo(() => ({ ...xrValue,
    ...interactionsValue
  }), [xrValue, interactionsValue]);
  return contextValue;
};
const useXRFrame = callback => {
  const {
    gl
  } = useThree();
  const requestRef = React.useRef();
  const previousTimeRef = React.useRef();
  const loop = React.useCallback((time, xrFrame) => {
    if (previousTimeRef.current !== undefined) {
      callback(time, xrFrame);
    }

    previousTimeRef.current = time;
    requestRef.current = gl.xr.getSession().requestAnimationFrame(loop);
  }, [gl.xr, callback]);
  React.useEffect(() => {
    var _gl$xr;

    if (!((_gl$xr = gl.xr) == null ? void 0 : _gl$xr.isPresenting)) {
      return;
    }

    requestRef.current = gl.xr.getSession().requestAnimationFrame(loop);
    return () => {
      if (requestRef.current) {
        gl.xr.getSession().cancelAnimationFrame(requestRef.current);
      }
    };
  }, [gl.xr.isPresenting, loop, gl.xr]);
};
const useController = handedness => {
  const {
    controllers
  } = useXR();
  const controller = React.useMemo(() => controllers.find(it => it.inputSource.handedness === handedness), [handedness, controllers]);
  return controller;
};

const DEFAULT_PROFILES_PATH = 'https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets@1.0/dist/profiles';
const DEFAULT_PROFILE = 'generic-trigger';

class XRControllerModel extends Object3D {
  constructor() {
    super();
    this.motionController = null;
    this.envMap = null;
  }

  setEnvironmentMap(envMap) {
    if (this.envMap == envMap) {
      return this;
    }

    this.envMap = envMap;
    this.traverse(child => {
      if (child.isMesh) {
        child.material.envMap = this.envMap;
        child.material.needsUpdate = true;
      }
    });
    return this;
  }
  /**
   * Polls data from the XRInputSource and updates the model's components to match
   * the real world data
   */


  updateMatrixWorld(force) {
    super.updateMatrixWorld(force);
    if (!this.motionController) return; // Cause the MotionController to poll the Gamepad for data

    this.motionController.updateFromGamepad(); // Update the 3D model to reflect the button, thumbstick, and touchpad state

    Object.values(this.motionController.components).forEach(component => {
      // Update node data based on the visual responses' current states
      Object.values(component.visualResponses).forEach(visualResponse => {
        const {
          valueNode,
          minNode,
          maxNode,
          value,
          valueNodeProperty
        } = visualResponse; // Skip if the visual response node is not found. No error is needed,
        // because it will have been reported at load time.

        if (!valueNode) return; // Calculate the new properties based on the weight supplied

        if (valueNodeProperty === Constants.VisualResponseProperty.VISIBILITY) {
          valueNode.visible = value;
        } else if (valueNodeProperty === Constants.VisualResponseProperty.TRANSFORM) {
          valueNode.quaternion.slerpQuaternions(minNode.quaternion, maxNode.quaternion, value);
          valueNode.position.lerpVectors(minNode.position, maxNode.position, value);
        }
      });
    });
  }

}
/**
 * Walks the model's tree to find the nodes needed to animate the components and
 * saves them to the motionContoller components for use in the frame loop. When
 * touchpads are found, attaches a touch dot to them.
 */


function findNodes(motionController, scene) {
  // Loop through the components and find the nodes needed for each components' visual responses
  Object.values(motionController.components).forEach(component => {
    const {
      type,
      touchPointNodeName,
      visualResponses
    } = component;

    if (type === Constants.ComponentType.TOUCHPAD) {
      component.touchPointNode = scene.getObjectByName(touchPointNodeName);

      if (component.touchPointNode) {
        // Attach a touch dot to the touchpad.
        const sphereGeometry = new SphereGeometry(0.001);
        const material = new MeshBasicMaterial({
          color: 0x0000ff
        });
        const sphere = new Mesh(sphereGeometry, material);
        component.touchPointNode.add(sphere);
      } else {
        console.warn(`Could not find touch dot, ${component.touchPointNodeName}, in touchpad component ${component.id}`);
      }
    } // Loop through all the visual responses to be applied to this component


    Object.values(visualResponses).forEach(visualResponse => {
      const {
        valueNodeName,
        minNodeName,
        maxNodeName,
        valueNodeProperty
      } = visualResponse; // If animating a transform, find the two nodes to be interpolated between.

      if (valueNodeProperty === Constants.VisualResponseProperty.TRANSFORM) {
        visualResponse.minNode = scene.getObjectByName(minNodeName);
        visualResponse.maxNode = scene.getObjectByName(maxNodeName); // If the extents cannot be found, skip this animation

        if (!visualResponse.minNode) {
          console.warn(`Could not find ${minNodeName} in the model`);
          return;
        }

        if (!visualResponse.maxNode) {
          console.warn(`Could not find ${maxNodeName} in the model`);
          return;
        }
      } // If the target node cannot be found, skip this animation


      visualResponse.valueNode = scene.getObjectByName(valueNodeName);

      if (!visualResponse.valueNode) {
        console.warn(`Could not find ${valueNodeName} in the model`);
      }
    });
  });
}

function addAssetSceneToControllerModel(controllerModel, scene) {
  // Find the nodes needed for animation and cache them on the motionController.
  findNodes(controllerModel.motionController, scene); // Apply any environment map that the mesh already has set.

  if (controllerModel.envMap) {
    scene.traverse(child => {
      if (child.isMesh) {
        child.material.envMap = controllerModel.envMap;
        child.material.needsUpdate = true;
      }
    });
  } // Add the glTF scene to the controllerModel.


  controllerModel.add(scene);
}

class XRControllerModelFactory {
  constructor(gltfLoader = null) {
    this.gltfLoader = gltfLoader;
    this.path = DEFAULT_PROFILES_PATH;
    this._assetCache = {}; // If a GLTFLoader wasn't supplied to the constructor create a new one.

    if (!this.gltfLoader) {
      this.gltfLoader = new GLTFLoader();
    }
  }

  createControllerModel(controller) {
    const controllerModel = new XRControllerModel();
    let scene = null;
    controller.addEventListener('connected', event => {
      const xrInputSource = event.data;
      if (xrInputSource.targetRayMode !== 'tracked-pointer' || !xrInputSource.gamepad) return;
      fetchProfile(xrInputSource, this.path, DEFAULT_PROFILE).then(({
        profile,
        assetPath
      }) => {
        controllerModel.motionController = new MotionController(xrInputSource, profile, assetPath);
        const cachedAsset = this._assetCache[controllerModel.motionController.assetUrl];

        if (cachedAsset) {
          scene = cachedAsset.scene.clone();
          addAssetSceneToControllerModel(controllerModel, scene);
        } else {
          if (!this.gltfLoader) {
            throw new Error('GLTFLoader not set.');
          }

          this.gltfLoader.setPath('');
          this.gltfLoader.load(controllerModel.motionController.assetUrl, asset => {
            this._assetCache[controllerModel.motionController.assetUrl] = asset;
            scene = asset.scene.clone();
            addAssetSceneToControllerModel(controllerModel, scene);
          }, null, () => {
            throw new Error(`Asset ${controllerModel.motionController.assetUrl} missing or malformed.`);
          });
        }
      }).catch(err => {
        console.warn(err);
      });
    });
    controller.addEventListener('disconnected', () => {
      controllerModel.motionController = null;
      controllerModel.remove(scene);
      scene = null;
    });
    return controllerModel;
  }

}

const modelFactory = new XRControllerModelFactory();
const modelCache = new WeakMap();
function DefaultXRControllers({
  rayMaterial = {}
}) {
  const {
    scene
  } = useThree();
  const {
    controllers,
    hoverState
  } = useXR();
  const [rays] = React__default.useState(new Map()); // Show ray line when hovering objects

  useFrame(() => {
    controllers.forEach(it => {
      const ray = rays.get(it.controller.id);
      if (!ray) return;
      const intersection = hoverState[it.inputSource.handedness].values().next().value;

      if (!intersection || it.inputSource.handedness === 'none') {
        ray.visible = false;
        return;
      }

      const rayLength = intersection.distance; // Tiny offset to clip ray on AR devices
      // that don't have handedness set to 'none'

      const offset = -0.01;
      ray.visible = true;
      ray.scale.y = rayLength + offset;
      ray.position.z = -rayLength / 2 - offset;
    });
  });
  useEffect(() => {
    const cleanups = [];
    controllers.forEach(({
      controller,
      grip,
      inputSource
    }) => {
      // Attach 3D model of the controller
      let model;

      if (modelCache.has(controller)) {
        model = modelCache.get(controller);
      } else {
        model = modelFactory.createControllerModel(controller);
        controller.dispatchEvent({
          type: 'connected',
          data: inputSource,
          fake: true
        });
        modelCache.set(controller, model);
      }

      grip.add(model); // Add Ray line (used for hovering)

      const ray = new Mesh();
      ray.rotation.set(Math.PI / 2, 0, 0);
      ray.material = new MeshBasicMaterial({
        color: new Color(0xffffff),
        opacity: 0.8,
        transparent: true,
        ...rayMaterial
      });
      ray.geometry = new BoxBufferGeometry(0.002, 1, 0.002);
      rays.set(controller.id, ray);
      controller.add(ray);
      cleanups.push(() => {
        grip.remove(model);
        controller.remove(ray);
        rays.delete(controller.id);
      });
    });
    return () => {
      cleanups.forEach(fn => fn());
    }; // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [controllers, scene, rays, JSON.stringify(rayMaterial)]);
  return null;
}

const DEFAULT_HAND_PROFILE_PATH = 'https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets@1.0/dist/profiles/generic-hand/';

class XRHandMeshModel {
  constructor(handModel, controller, path, handedness, customModel) {
    this.controller = controller;
    this.handModel = handModel;
    this.bones = [];
    const loader = new GLTFLoader();
    if (!customModel) loader.setPath(path || DEFAULT_HAND_PROFILE_PATH);
    loader.load(customModel != null ? customModel : `${handedness}.glb`, gltf => {
      const object = gltf.scene.children[0];
      this.handModel.add(object);
      const mesh = object.getObjectByProperty('type', 'SkinnedMesh');
      mesh.frustumCulled = false;
      mesh.castShadow = true;
      mesh.receiveShadow = true;
      mesh.material.side = 0; // Workaround: force FrontSide

      const joints = ['wrist', 'thumb-metacarpal', 'thumb-phalanx-proximal', 'thumb-phalanx-distal', 'thumb-tip', 'index-finger-metacarpal', 'index-finger-phalanx-proximal', 'index-finger-phalanx-intermediate', 'index-finger-phalanx-distal', 'index-finger-tip', 'middle-finger-metacarpal', 'middle-finger-phalanx-proximal', 'middle-finger-phalanx-intermediate', 'middle-finger-phalanx-distal', 'middle-finger-tip', 'ring-finger-metacarpal', 'ring-finger-phalanx-proximal', 'ring-finger-phalanx-intermediate', 'ring-finger-phalanx-distal', 'ring-finger-tip', 'pinky-finger-metacarpal', 'pinky-finger-phalanx-proximal', 'pinky-finger-phalanx-intermediate', 'pinky-finger-phalanx-distal', 'pinky-finger-tip'];
      joints.forEach(jointName => {
        const bone = object.getObjectByName(jointName);

        if (bone !== undefined) {
          bone.jointName = jointName;
        } else {
          console.warn(`Couldn't find ${jointName} in ${handedness} hand mesh`);
        }

        this.bones.push(bone);
      });
    });
  }

  updateMesh() {
    // XR Joints
    const XRJoints = this.controller.joints;

    for (let i = 0; i < this.bones.length; i++) {
      const bone = this.bones[i];

      if (bone) {
        const XRJoint = XRJoints[bone.jointName];

        if (XRJoint.visible) {
          const position = XRJoint.position;

          if (bone) {
            bone.position.copy(position);
            bone.quaternion.copy(XRJoint.quaternion); // bone.scale.setScalar( XRJoint.jointRadius || defaultRadius );
          }
        }
      }
    }
  }

}

const TOUCH_RADIUS = 0.01;
const POINTING_JOINT = 'index-finger-tip';

class HandModel extends Object3D {
  constructor(controller, customModels) {
    super();
    this.controller = controller;
    this.motionController = null;
    this.envMap = null;
    this.mesh = null;
    controller.addEventListener('connected', event => {
      const xrInputSource = event.data;

      if (xrInputSource.hand && !this.motionController) {
        this.xrInputSource = xrInputSource;
        this.motionController = new XRHandMeshModel(this, controller, this.path, xrInputSource.handedness, xrInputSource.handedness === "left" ? customModels[0] : customModels[1]);
      }
    });
    controller.addEventListener('disconnected', () => {
      this.clear();
      this.motionController = null;
    });
  }

  updateMatrixWorld(force) {
    super.updateMatrixWorld(force);

    if (this.motionController) {
      this.motionController.updateMesh();
    }
  }

  getPointerPosition() {
    const indexFingerTip = this.controller.joints[POINTING_JOINT];

    if (indexFingerTip) {
      return indexFingerTip.position;
    } else {
      return null;
    }
  }

  intersectBoxObject(boxObject) {
    const pointerPosition = this.getPointerPosition();

    if (pointerPosition) {
      const indexSphere = new Sphere(pointerPosition, TOUCH_RADIUS);
      const box = new Box3().setFromObject(boxObject);
      return indexSphere.intersectsBox(box);
    } else {
      return false;
    }
  }

  checkButton(button) {
    if (this.intersectBoxObject(button)) {
      button.onPress();
    } else {
      button.onClear();
    }

    if (button.isPressed()) {
      button.whilePressed();
    }
  }

}

function Hands(props) {
  const {
    scene,
    gl
  } = useThree();
  const {
    controllers
  } = useXR();
  useEffect(() => {
    controllers.forEach(({
      hand,
      inputSource
    }) => {
      const handModel = hand.children.find(child => child instanceof HandModel);

      if (handModel === undefined) {
        hand.add(new HandModel(hand, [props.modelLeft, props.modelRight])); // throwing fake event for the Oculus Hand Model so it starts loading

        hand.dispatchEvent({
          type: 'connected',
          data: inputSource,
          fake: true
        });
      }
    });
  }, [scene, gl, controllers]);
  return null;
}

export { ARCanvas, DefaultXRControllers, Hands, InteractionManager, InteractionsContext, Interactive, RayGrab, VRCanvas, XR, XRController, useController, useHitTest, useInteraction, useXR, useXREvent, useXRFrame };
