{"ast":null,"code":"import _classCallCheck from \"/Users/lordokami/lordokami/lost-my-keys-vr/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/lordokami/lordokami/lost-my-keys-vr/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"/Users/lordokami/lordokami/lost-my-keys-vr/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/lordokami/lordokami/lost-my-keys-vr/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { Curve, Vector3, Vector4 } from 'three';\nimport * as NURBSUtils from '../curves/NURBSUtils.js';\n/**\n * NURBS curve object\n *\n * Derives from Curve, overriding getPoint and getTangent.\n *\n * Implementation is based on (x, y [, z=0 [, w=1]]) control points with w=weight.\n *\n **/\n\nvar NURBSCurve = /*#__PURE__*/function (_Curve) {\n  _inherits(NURBSCurve, _Curve);\n\n  var _super = _createSuper(NURBSCurve);\n\n  function NURBSCurve(degree, knots\n  /* array of reals */\n  , controlPoints\n  /* array of Vector(2|3|4) */\n  , startKnot\n  /* index in knots */\n  , endKnot\n  /* index in knots */\n  ) {\n    var _this;\n\n    _classCallCheck(this, NURBSCurve);\n\n    _this = _super.call(this);\n    _this.degree = degree;\n    _this.knots = knots;\n    _this.controlPoints = []; // Used by periodic NURBS to remove hidden spans\n\n    _this.startKnot = startKnot || 0;\n    _this.endKnot = endKnot || _this.knots.length - 1;\n\n    for (var i = 0; i < controlPoints.length; ++i) {\n      // ensure Vector4 for control points\n      var point = controlPoints[i];\n      _this.controlPoints[i] = new Vector4(point.x, point.y, point.z, point.w);\n    }\n\n    return _this;\n  }\n\n  _createClass(NURBSCurve, [{\n    key: \"getPoint\",\n    value: function getPoint(t) {\n      var optionalTarget = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector3();\n      var point = optionalTarget;\n      var u = this.knots[this.startKnot] + t * (this.knots[this.endKnot] - this.knots[this.startKnot]); // linear mapping t->u\n      // following results in (wx, wy, wz, w) homogeneous point\n\n      var hpoint = NURBSUtils.calcBSplinePoint(this.degree, this.knots, this.controlPoints, u);\n\n      if (hpoint.w !== 1.0) {\n        // project to 3D space: (wx, wy, wz, w) -> (x, y, z, 1)\n        hpoint.divideScalar(hpoint.w);\n      }\n\n      return point.set(hpoint.x, hpoint.y, hpoint.z);\n    }\n  }, {\n    key: \"getTangent\",\n    value: function getTangent(t) {\n      var optionalTarget = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector3();\n      var tangent = optionalTarget;\n      var u = this.knots[0] + t * (this.knots[this.knots.length - 1] - this.knots[0]);\n      var ders = NURBSUtils.calcNURBSDerivatives(this.degree, this.knots, this.controlPoints, u, 1);\n      tangent.copy(ders[1]).normalize();\n      return tangent;\n    }\n  }]);\n\n  return NURBSCurve;\n}(Curve);\n\nexport { NURBSCurve };","map":{"version":3,"sources":["/Users/lordokami/lordokami/lost-my-keys-vr/node_modules/three/examples/jsm/curves/NURBSCurve.js"],"names":["Curve","Vector3","Vector4","NURBSUtils","NURBSCurve","degree","knots","controlPoints","startKnot","endKnot","length","i","point","x","y","z","w","t","optionalTarget","u","hpoint","calcBSplinePoint","divideScalar","set","tangent","ders","calcNURBSDerivatives","copy","normalize"],"mappings":";;;;AAAA,SACCA,KADD,EAECC,OAFD,EAGCC,OAHD,QAIO,OAJP;AAKA,OAAO,KAAKC,UAAZ,MAA4B,yBAA5B;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;IAEMC,U;;;;;AAEL,sBACCC,MADD,EAECC;AAAM;AAFP,IAGCC;AAAc;AAHf,IAICC;AAAU;AAJX,IAKCC;AAAQ;AALT,IAME;AAAA;;AAAA;;AAED;AAEA,UAAKJ,MAAL,GAAcA,MAAd;AACA,UAAKC,KAAL,GAAaA,KAAb;AACA,UAAKC,aAAL,GAAqB,EAArB,CANC,CAOD;;AACA,UAAKC,SAAL,GAAiBA,SAAS,IAAI,CAA9B;AACA,UAAKC,OAAL,GAAeA,OAAO,IAAM,MAAKH,KAAL,CAAWI,MAAX,GAAoB,CAAhD;;AAEA,SAAM,IAAIC,CAAC,GAAG,CAAd,EAAiBA,CAAC,GAAGJ,aAAa,CAACG,MAAnC,EAA2C,EAAGC,CAA9C,EAAkD;AAEjD;AACA,UAAMC,KAAK,GAAGL,aAAa,CAAEI,CAAF,CAA3B;AACA,YAAKJ,aAAL,CAAoBI,CAApB,IAA0B,IAAIT,OAAJ,CAAaU,KAAK,CAACC,CAAnB,EAAsBD,KAAK,CAACE,CAA5B,EAA+BF,KAAK,CAACG,CAArC,EAAwCH,KAAK,CAACI,CAA9C,CAA1B;AAEA;;AAjBA;AAmBD;;;;WAED,kBAAUC,CAAV,EAA8C;AAAA,UAAjCC,cAAiC,uEAAhB,IAAIjB,OAAJ,EAAgB;AAE7C,UAAMW,KAAK,GAAGM,cAAd;AAEA,UAAMC,CAAC,GAAG,KAAKb,KAAL,CAAY,KAAKE,SAAjB,IAA+BS,CAAC,IAAK,KAAKX,KAAL,CAAY,KAAKG,OAAjB,IAA6B,KAAKH,KAAL,CAAY,KAAKE,SAAjB,CAAlC,CAA1C,CAJ6C,CAI+D;AAE5G;;AACA,UAAMY,MAAM,GAAGjB,UAAU,CAACkB,gBAAX,CAA6B,KAAKhB,MAAlC,EAA0C,KAAKC,KAA/C,EAAsD,KAAKC,aAA3D,EAA0EY,CAA1E,CAAf;;AAEA,UAAKC,MAAM,CAACJ,CAAP,KAAa,GAAlB,EAAwB;AAEvB;AACAI,QAAAA,MAAM,CAACE,YAAP,CAAqBF,MAAM,CAACJ,CAA5B;AAEA;;AAED,aAAOJ,KAAK,CAACW,GAAN,CAAWH,MAAM,CAACP,CAAlB,EAAqBO,MAAM,CAACN,CAA5B,EAA+BM,MAAM,CAACL,CAAtC,CAAP;AAEA;;;WAED,oBAAYE,CAAZ,EAAgD;AAAA,UAAjCC,cAAiC,uEAAhB,IAAIjB,OAAJ,EAAgB;AAE/C,UAAMuB,OAAO,GAAGN,cAAhB;AAEA,UAAMC,CAAC,GAAG,KAAKb,KAAL,CAAY,CAAZ,IAAkBW,CAAC,IAAK,KAAKX,KAAL,CAAY,KAAKA,KAAL,CAAWI,MAAX,GAAoB,CAAhC,IAAsC,KAAKJ,KAAL,CAAY,CAAZ,CAA3C,CAA7B;AACA,UAAMmB,IAAI,GAAGtB,UAAU,CAACuB,oBAAX,CAAiC,KAAKrB,MAAtC,EAA8C,KAAKC,KAAnD,EAA0D,KAAKC,aAA/D,EAA8EY,CAA9E,EAAiF,CAAjF,CAAb;AACAK,MAAAA,OAAO,CAACG,IAAR,CAAcF,IAAI,CAAE,CAAF,CAAlB,EAA0BG,SAA1B;AAEA,aAAOJ,OAAP;AAEA;;;;EA3DuBxB,K;;AA+DzB,SAASI,UAAT","sourcesContent":["import {\n\tCurve,\n\tVector3,\n\tVector4\n} from 'three';\nimport * as NURBSUtils from '../curves/NURBSUtils.js';\n\n/**\n * NURBS curve object\n *\n * Derives from Curve, overriding getPoint and getTangent.\n *\n * Implementation is based on (x, y [, z=0 [, w=1]]) control points with w=weight.\n *\n **/\n\nclass NURBSCurve extends Curve {\n\n\tconstructor(\n\t\tdegree,\n\t\tknots /* array of reals */,\n\t\tcontrolPoints /* array of Vector(2|3|4) */,\n\t\tstartKnot /* index in knots */,\n\t\tendKnot /* index in knots */\n\t) {\n\n\t\tsuper();\n\n\t\tthis.degree = degree;\n\t\tthis.knots = knots;\n\t\tthis.controlPoints = [];\n\t\t// Used by periodic NURBS to remove hidden spans\n\t\tthis.startKnot = startKnot || 0;\n\t\tthis.endKnot = endKnot || ( this.knots.length - 1 );\n\n\t\tfor ( let i = 0; i < controlPoints.length; ++ i ) {\n\n\t\t\t// ensure Vector4 for control points\n\t\t\tconst point = controlPoints[ i ];\n\t\t\tthis.controlPoints[ i ] = new Vector4( point.x, point.y, point.z, point.w );\n\n\t\t}\n\n\t}\n\n\tgetPoint( t, optionalTarget = new Vector3() ) {\n\n\t\tconst point = optionalTarget;\n\n\t\tconst u = this.knots[ this.startKnot ] + t * ( this.knots[ this.endKnot ] - this.knots[ this.startKnot ] ); // linear mapping t->u\n\n\t\t// following results in (wx, wy, wz, w) homogeneous point\n\t\tconst hpoint = NURBSUtils.calcBSplinePoint( this.degree, this.knots, this.controlPoints, u );\n\n\t\tif ( hpoint.w !== 1.0 ) {\n\n\t\t\t// project to 3D space: (wx, wy, wz, w) -> (x, y, z, 1)\n\t\t\thpoint.divideScalar( hpoint.w );\n\n\t\t}\n\n\t\treturn point.set( hpoint.x, hpoint.y, hpoint.z );\n\n\t}\n\n\tgetTangent( t, optionalTarget = new Vector3() ) {\n\n\t\tconst tangent = optionalTarget;\n\n\t\tconst u = this.knots[ 0 ] + t * ( this.knots[ this.knots.length - 1 ] - this.knots[ 0 ] );\n\t\tconst ders = NURBSUtils.calcNURBSDerivatives( this.degree, this.knots, this.controlPoints, u, 1 );\n\t\ttangent.copy( ders[ 1 ] ).normalize();\n\n\t\treturn tangent;\n\n\t}\n\n}\n\nexport { NURBSCurve };\n"]},"metadata":{},"sourceType":"module"}