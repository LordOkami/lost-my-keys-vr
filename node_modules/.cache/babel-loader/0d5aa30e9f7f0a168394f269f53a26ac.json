{"ast":null,"code":"import _classCallCheck from \"/Users/lordokami/lordokami/lost-my-keys-vr/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/lordokami/lordokami/lost-my-keys-vr/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"/Users/lordokami/lordokami/lost-my-keys-vr/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/lordokami/lordokami/lost-my-keys-vr/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { BufferAttribute, BufferGeometry, FileLoader, Loader } from 'three';\n\nvar _taskCache = new WeakMap();\n\nvar DRACOLoader = /*#__PURE__*/function (_Loader) {\n  _inherits(DRACOLoader, _Loader);\n\n  var _super = _createSuper(DRACOLoader);\n\n  function DRACOLoader(manager) {\n    var _this;\n\n    _classCallCheck(this, DRACOLoader);\n\n    _this = _super.call(this, manager);\n    _this.decoderPath = '';\n    _this.decoderConfig = {};\n    _this.decoderBinary = null;\n    _this.decoderPending = null;\n    _this.workerLimit = 4;\n    _this.workerPool = [];\n    _this.workerNextTaskID = 1;\n    _this.workerSourceURL = '';\n    _this.defaultAttributeIDs = {\n      position: 'POSITION',\n      normal: 'NORMAL',\n      color: 'COLOR',\n      uv: 'TEX_COORD'\n    };\n    _this.defaultAttributeTypes = {\n      position: 'Float32Array',\n      normal: 'Float32Array',\n      color: 'Float32Array',\n      uv: 'Float32Array'\n    };\n    return _this;\n  }\n\n  _createClass(DRACOLoader, [{\n    key: \"setDecoderPath\",\n    value: function setDecoderPath(path) {\n      this.decoderPath = path;\n      return this;\n    }\n  }, {\n    key: \"setDecoderConfig\",\n    value: function setDecoderConfig(config) {\n      this.decoderConfig = config;\n      return this;\n    }\n  }, {\n    key: \"setWorkerLimit\",\n    value: function setWorkerLimit(workerLimit) {\n      this.workerLimit = workerLimit;\n      return this;\n    }\n  }, {\n    key: \"load\",\n    value: function load(url, onLoad, onProgress, onError) {\n      var _this2 = this;\n\n      var loader = new FileLoader(this.manager);\n      loader.setPath(this.path);\n      loader.setResponseType('arraybuffer');\n      loader.setRequestHeader(this.requestHeader);\n      loader.setWithCredentials(this.withCredentials);\n      loader.load(url, function (buffer) {\n        var taskConfig = {\n          attributeIDs: _this2.defaultAttributeIDs,\n          attributeTypes: _this2.defaultAttributeTypes,\n          useUniqueIDs: false\n        };\n\n        _this2.decodeGeometry(buffer, taskConfig).then(onLoad).catch(onError);\n      }, onProgress, onError);\n    }\n    /** @deprecated Kept for backward-compatibility with previous DRACOLoader versions. */\n\n  }, {\n    key: \"decodeDracoFile\",\n    value: function decodeDracoFile(buffer, callback, attributeIDs, attributeTypes) {\n      var taskConfig = {\n        attributeIDs: attributeIDs || this.defaultAttributeIDs,\n        attributeTypes: attributeTypes || this.defaultAttributeTypes,\n        useUniqueIDs: !!attributeIDs\n      };\n      this.decodeGeometry(buffer, taskConfig).then(callback);\n    }\n  }, {\n    key: \"decodeGeometry\",\n    value: function decodeGeometry(buffer, taskConfig) {\n      var _this3 = this;\n\n      // TODO: For backward-compatibility, support 'attributeTypes' objects containing\n      // references (rather than names) to typed array constructors. These must be\n      // serialized before sending them to the worker.\n      for (var attribute in taskConfig.attributeTypes) {\n        var type = taskConfig.attributeTypes[attribute];\n\n        if (type.BYTES_PER_ELEMENT !== undefined) {\n          taskConfig.attributeTypes[attribute] = type.name;\n        }\n      } //\n\n\n      var taskKey = JSON.stringify(taskConfig); // Check for an existing task using this buffer. A transferred buffer cannot be transferred\n      // again from this thread.\n\n      if (_taskCache.has(buffer)) {\n        var cachedTask = _taskCache.get(buffer);\n\n        if (cachedTask.key === taskKey) {\n          return cachedTask.promise;\n        } else if (buffer.byteLength === 0) {\n          // Technically, it would be possible to wait for the previous task to complete,\n          // transfer the buffer back, and decode again with the second configuration. That\n          // is complex, and I don't know of any reason to decode a Draco buffer twice in\n          // different ways, so this is left unimplemented.\n          throw new Error('THREE.DRACOLoader: Unable to re-decode a buffer with different ' + 'settings. Buffer has already been transferred.');\n        }\n      } //\n\n\n      var worker;\n      var taskID = this.workerNextTaskID++;\n      var taskCost = buffer.byteLength; // Obtain a worker and assign a task, and construct a geometry instance\n      // when the task completes.\n\n      var geometryPending = this._getWorker(taskID, taskCost).then(function (_worker) {\n        worker = _worker;\n        return new Promise(function (resolve, reject) {\n          worker._callbacks[taskID] = {\n            resolve: resolve,\n            reject: reject\n          };\n          worker.postMessage({\n            type: 'decode',\n            id: taskID,\n            taskConfig: taskConfig,\n            buffer: buffer\n          }, [buffer]); // this.debug();\n        });\n      }).then(function (message) {\n        return _this3._createGeometry(message.geometry);\n      }); // Remove task from the task list.\n      // Note: replaced '.finally()' with '.catch().then()' block - iOS 11 support (#19416)\n\n\n      geometryPending.catch(function () {\n        return true;\n      }).then(function () {\n        if (worker && taskID) {\n          _this3._releaseTask(worker, taskID); // this.debug();\n\n        }\n      }); // Cache the task result.\n\n      _taskCache.set(buffer, {\n        key: taskKey,\n        promise: geometryPending\n      });\n\n      return geometryPending;\n    }\n  }, {\n    key: \"_createGeometry\",\n    value: function _createGeometry(geometryData) {\n      var geometry = new BufferGeometry();\n\n      if (geometryData.index) {\n        geometry.setIndex(new BufferAttribute(geometryData.index.array, 1));\n      }\n\n      for (var i = 0; i < geometryData.attributes.length; i++) {\n        var attribute = geometryData.attributes[i];\n        var name = attribute.name;\n        var array = attribute.array;\n        var itemSize = attribute.itemSize;\n        geometry.setAttribute(name, new BufferAttribute(array, itemSize));\n      }\n\n      return geometry;\n    }\n  }, {\n    key: \"_loadLibrary\",\n    value: function _loadLibrary(url, responseType) {\n      var loader = new FileLoader(this.manager);\n      loader.setPath(this.decoderPath);\n      loader.setResponseType(responseType);\n      loader.setWithCredentials(this.withCredentials);\n      return new Promise(function (resolve, reject) {\n        loader.load(url, resolve, undefined, reject);\n      });\n    }\n  }, {\n    key: \"preload\",\n    value: function preload() {\n      this._initDecoder();\n\n      return this;\n    }\n  }, {\n    key: \"_initDecoder\",\n    value: function _initDecoder() {\n      var _this4 = this;\n\n      if (this.decoderPending) return this.decoderPending;\n      var useJS = typeof WebAssembly !== 'object' || this.decoderConfig.type === 'js';\n      var librariesPending = [];\n\n      if (useJS) {\n        librariesPending.push(this._loadLibrary('draco_decoder.js', 'text'));\n      } else {\n        librariesPending.push(this._loadLibrary('draco_wasm_wrapper.js', 'text'));\n        librariesPending.push(this._loadLibrary('draco_decoder.wasm', 'arraybuffer'));\n      }\n\n      this.decoderPending = Promise.all(librariesPending).then(function (libraries) {\n        var jsContent = libraries[0];\n\n        if (!useJS) {\n          _this4.decoderConfig.wasmBinary = libraries[1];\n        }\n\n        var fn = DRACOWorker.toString();\n        var body = ['/* draco decoder */', jsContent, '', '/* worker */', fn.substring(fn.indexOf('{') + 1, fn.lastIndexOf('}'))].join('\\n');\n        _this4.workerSourceURL = URL.createObjectURL(new Blob([body]));\n      });\n      return this.decoderPending;\n    }\n  }, {\n    key: \"_getWorker\",\n    value: function _getWorker(taskID, taskCost) {\n      var _this5 = this;\n\n      return this._initDecoder().then(function () {\n        if (_this5.workerPool.length < _this5.workerLimit) {\n          var _worker2 = new Worker(_this5.workerSourceURL);\n\n          _worker2._callbacks = {};\n          _worker2._taskCosts = {};\n          _worker2._taskLoad = 0;\n\n          _worker2.postMessage({\n            type: 'init',\n            decoderConfig: _this5.decoderConfig\n          });\n\n          _worker2.onmessage = function (e) {\n            var message = e.data;\n\n            switch (message.type) {\n              case 'decode':\n                _worker2._callbacks[message.id].resolve(message);\n\n                break;\n\n              case 'error':\n                _worker2._callbacks[message.id].reject(message);\n\n                break;\n\n              default:\n                console.error('THREE.DRACOLoader: Unexpected message, \"' + message.type + '\"');\n            }\n          };\n\n          _this5.workerPool.push(_worker2);\n        } else {\n          _this5.workerPool.sort(function (a, b) {\n            return a._taskLoad > b._taskLoad ? -1 : 1;\n          });\n        }\n\n        var worker = _this5.workerPool[_this5.workerPool.length - 1];\n        worker._taskCosts[taskID] = taskCost;\n        worker._taskLoad += taskCost;\n        return worker;\n      });\n    }\n  }, {\n    key: \"_releaseTask\",\n    value: function _releaseTask(worker, taskID) {\n      worker._taskLoad -= worker._taskCosts[taskID];\n      delete worker._callbacks[taskID];\n      delete worker._taskCosts[taskID];\n    }\n  }, {\n    key: \"debug\",\n    value: function debug() {\n      console.log('Task load: ', this.workerPool.map(function (worker) {\n        return worker._taskLoad;\n      }));\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      for (var i = 0; i < this.workerPool.length; ++i) {\n        this.workerPool[i].terminate();\n      }\n\n      this.workerPool.length = 0;\n      return this;\n    }\n  }]);\n\n  return DRACOLoader;\n}(Loader);\n/* WEB WORKER */\n\n\nfunction DRACOWorker() {\n  var decoderConfig;\n  var decoderPending;\n\n  onmessage = function onmessage(e) {\n    var message = e.data;\n\n    switch (message.type) {\n      case 'init':\n        decoderConfig = message.decoderConfig;\n        decoderPending = new Promise(function (resolve\n        /*, reject*/\n        ) {\n          decoderConfig.onModuleLoaded = function (draco) {\n            // Module is Promise-like. Wrap before resolving to avoid loop.\n            resolve({\n              draco: draco\n            });\n          };\n\n          DracoDecoderModule(decoderConfig); // eslint-disable-line no-undef\n        });\n        break;\n\n      case 'decode':\n        var buffer = message.buffer;\n        var taskConfig = message.taskConfig;\n        decoderPending.then(function (module) {\n          var draco = module.draco;\n          var decoder = new draco.Decoder();\n          var decoderBuffer = new draco.DecoderBuffer();\n          decoderBuffer.Init(new Int8Array(buffer), buffer.byteLength);\n\n          try {\n            var geometry = decodeGeometry(draco, decoder, decoderBuffer, taskConfig);\n            var buffers = geometry.attributes.map(function (attr) {\n              return attr.array.buffer;\n            });\n            if (geometry.index) buffers.push(geometry.index.array.buffer);\n            self.postMessage({\n              type: 'decode',\n              id: message.id,\n              geometry: geometry\n            }, buffers);\n          } catch (error) {\n            console.error(error);\n            self.postMessage({\n              type: 'error',\n              id: message.id,\n              error: error.message\n            });\n          } finally {\n            draco.destroy(decoderBuffer);\n            draco.destroy(decoder);\n          }\n        });\n        break;\n    }\n  };\n\n  function decodeGeometry(draco, decoder, decoderBuffer, taskConfig) {\n    var attributeIDs = taskConfig.attributeIDs;\n    var attributeTypes = taskConfig.attributeTypes;\n    var dracoGeometry;\n    var decodingStatus;\n    var geometryType = decoder.GetEncodedGeometryType(decoderBuffer);\n\n    if (geometryType === draco.TRIANGULAR_MESH) {\n      dracoGeometry = new draco.Mesh();\n      decodingStatus = decoder.DecodeBufferToMesh(decoderBuffer, dracoGeometry);\n    } else if (geometryType === draco.POINT_CLOUD) {\n      dracoGeometry = new draco.PointCloud();\n      decodingStatus = decoder.DecodeBufferToPointCloud(decoderBuffer, dracoGeometry);\n    } else {\n      throw new Error('THREE.DRACOLoader: Unexpected geometry type.');\n    }\n\n    if (!decodingStatus.ok() || dracoGeometry.ptr === 0) {\n      throw new Error('THREE.DRACOLoader: Decoding failed: ' + decodingStatus.error_msg());\n    }\n\n    var geometry = {\n      index: null,\n      attributes: []\n    }; // Gather all vertex attributes.\n\n    for (var attributeName in attributeIDs) {\n      var attributeType = self[attributeTypes[attributeName]];\n      var attribute = void 0;\n      var attributeID = void 0; // A Draco file may be created with default vertex attributes, whose attribute IDs\n      // are mapped 1:1 from their semantic name (POSITION, NORMAL, ...). Alternatively,\n      // a Draco file may contain a custom set of attributes, identified by known unique\n      // IDs. glTF files always do the latter, and `.drc` files typically do the former.\n\n      if (taskConfig.useUniqueIDs) {\n        attributeID = attributeIDs[attributeName];\n        attribute = decoder.GetAttributeByUniqueId(dracoGeometry, attributeID);\n      } else {\n        attributeID = decoder.GetAttributeId(dracoGeometry, draco[attributeIDs[attributeName]]);\n        if (attributeID === -1) continue;\n        attribute = decoder.GetAttribute(dracoGeometry, attributeID);\n      }\n\n      geometry.attributes.push(decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute));\n    } // Add index.\n\n\n    if (geometryType === draco.TRIANGULAR_MESH) {\n      geometry.index = decodeIndex(draco, decoder, dracoGeometry);\n    }\n\n    draco.destroy(dracoGeometry);\n    return geometry;\n  }\n\n  function decodeIndex(draco, decoder, dracoGeometry) {\n    var numFaces = dracoGeometry.num_faces();\n    var numIndices = numFaces * 3;\n    var byteLength = numIndices * 4;\n\n    var ptr = draco._malloc(byteLength);\n\n    decoder.GetTrianglesUInt32Array(dracoGeometry, byteLength, ptr);\n    var index = new Uint32Array(draco.HEAPF32.buffer, ptr, numIndices).slice();\n\n    draco._free(ptr);\n\n    return {\n      array: index,\n      itemSize: 1\n    };\n  }\n\n  function decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute) {\n    var numComponents = attribute.num_components();\n    var numPoints = dracoGeometry.num_points();\n    var numValues = numPoints * numComponents;\n    var byteLength = numValues * attributeType.BYTES_PER_ELEMENT;\n    var dataType = getDracoDataType(draco, attributeType);\n\n    var ptr = draco._malloc(byteLength);\n\n    decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, dataType, byteLength, ptr);\n    var array = new attributeType(draco.HEAPF32.buffer, ptr, numValues).slice();\n\n    draco._free(ptr);\n\n    return {\n      name: attributeName,\n      array: array,\n      itemSize: numComponents\n    };\n  }\n\n  function getDracoDataType(draco, attributeType) {\n    switch (attributeType) {\n      case Float32Array:\n        return draco.DT_FLOAT32;\n\n      case Int8Array:\n        return draco.DT_INT8;\n\n      case Int16Array:\n        return draco.DT_INT16;\n\n      case Int32Array:\n        return draco.DT_INT32;\n\n      case Uint8Array:\n        return draco.DT_UINT8;\n\n      case Uint16Array:\n        return draco.DT_UINT16;\n\n      case Uint32Array:\n        return draco.DT_UINT32;\n    }\n  }\n}\n\nexport { DRACOLoader };","map":{"version":3,"sources":["/Users/lordokami/lordokami/lost-my-keys-vr/node_modules/three/examples/jsm/loaders/DRACOLoader.js"],"names":["BufferAttribute","BufferGeometry","FileLoader","Loader","_taskCache","WeakMap","DRACOLoader","manager","decoderPath","decoderConfig","decoderBinary","decoderPending","workerLimit","workerPool","workerNextTaskID","workerSourceURL","defaultAttributeIDs","position","normal","color","uv","defaultAttributeTypes","path","config","url","onLoad","onProgress","onError","loader","setPath","setResponseType","setRequestHeader","requestHeader","setWithCredentials","withCredentials","load","buffer","taskConfig","attributeIDs","attributeTypes","useUniqueIDs","decodeGeometry","then","catch","callback","attribute","type","BYTES_PER_ELEMENT","undefined","name","taskKey","JSON","stringify","has","cachedTask","get","key","promise","byteLength","Error","worker","taskID","taskCost","geometryPending","_getWorker","_worker","Promise","resolve","reject","_callbacks","postMessage","id","message","_createGeometry","geometry","_releaseTask","set","geometryData","index","setIndex","array","i","attributes","length","itemSize","setAttribute","responseType","_initDecoder","useJS","WebAssembly","librariesPending","push","_loadLibrary","all","libraries","jsContent","wasmBinary","fn","DRACOWorker","toString","body","substring","indexOf","lastIndexOf","join","URL","createObjectURL","Blob","Worker","_taskCosts","_taskLoad","onmessage","e","data","console","error","sort","a","b","log","map","terminate","onModuleLoaded","draco","DracoDecoderModule","module","decoder","Decoder","decoderBuffer","DecoderBuffer","Init","Int8Array","buffers","attr","self","destroy","dracoGeometry","decodingStatus","geometryType","GetEncodedGeometryType","TRIANGULAR_MESH","Mesh","DecodeBufferToMesh","POINT_CLOUD","PointCloud","DecodeBufferToPointCloud","ok","ptr","error_msg","attributeName","attributeType","attributeID","GetAttributeByUniqueId","GetAttributeId","GetAttribute","decodeAttribute","decodeIndex","numFaces","num_faces","numIndices","_malloc","GetTrianglesUInt32Array","Uint32Array","HEAPF32","slice","_free","numComponents","num_components","numPoints","num_points","numValues","dataType","getDracoDataType","GetAttributeDataArrayForAllPoints","Float32Array","DT_FLOAT32","DT_INT8","Int16Array","DT_INT16","Int32Array","DT_INT32","Uint8Array","DT_UINT8","Uint16Array","DT_UINT16","DT_UINT32"],"mappings":";;;;AAAA,SACCA,eADD,EAECC,cAFD,EAGCC,UAHD,EAICC,MAJD,QAKO,OALP;;AAOA,IAAMC,UAAU,GAAG,IAAIC,OAAJ,EAAnB;;IAEMC,W;;;;;AAEL,uBAAaC,OAAb,EAAuB;AAAA;;AAAA;;AAEtB,8BAAOA,OAAP;AAEA,UAAKC,WAAL,GAAmB,EAAnB;AACA,UAAKC,aAAL,GAAqB,EAArB;AACA,UAAKC,aAAL,GAAqB,IAArB;AACA,UAAKC,cAAL,GAAsB,IAAtB;AAEA,UAAKC,WAAL,GAAmB,CAAnB;AACA,UAAKC,UAAL,GAAkB,EAAlB;AACA,UAAKC,gBAAL,GAAwB,CAAxB;AACA,UAAKC,eAAL,GAAuB,EAAvB;AAEA,UAAKC,mBAAL,GAA2B;AAC1BC,MAAAA,QAAQ,EAAE,UADgB;AAE1BC,MAAAA,MAAM,EAAE,QAFkB;AAG1BC,MAAAA,KAAK,EAAE,OAHmB;AAI1BC,MAAAA,EAAE,EAAE;AAJsB,KAA3B;AAMA,UAAKC,qBAAL,GAA6B;AAC5BJ,MAAAA,QAAQ,EAAE,cADkB;AAE5BC,MAAAA,MAAM,EAAE,cAFoB;AAG5BC,MAAAA,KAAK,EAAE,cAHqB;AAI5BC,MAAAA,EAAE,EAAE;AAJwB,KAA7B;AApBsB;AA2BtB;;;;WAED,wBAAgBE,IAAhB,EAAuB;AAEtB,WAAKd,WAAL,GAAmBc,IAAnB;AAEA,aAAO,IAAP;AAEA;;;WAED,0BAAkBC,MAAlB,EAA2B;AAE1B,WAAKd,aAAL,GAAqBc,MAArB;AAEA,aAAO,IAAP;AAEA;;;WAED,wBAAgBX,WAAhB,EAA8B;AAE7B,WAAKA,WAAL,GAAmBA,WAAnB;AAEA,aAAO,IAAP;AAEA;;;WAED,cAAMY,GAAN,EAAWC,MAAX,EAAmBC,UAAnB,EAA+BC,OAA/B,EAAyC;AAAA;;AAExC,UAAMC,MAAM,GAAG,IAAI1B,UAAJ,CAAgB,KAAKK,OAArB,CAAf;AAEAqB,MAAAA,MAAM,CAACC,OAAP,CAAgB,KAAKP,IAArB;AACAM,MAAAA,MAAM,CAACE,eAAP,CAAwB,aAAxB;AACAF,MAAAA,MAAM,CAACG,gBAAP,CAAyB,KAAKC,aAA9B;AACAJ,MAAAA,MAAM,CAACK,kBAAP,CAA2B,KAAKC,eAAhC;AAEAN,MAAAA,MAAM,CAACO,IAAP,CAAaX,GAAb,EAAkB,UAAEY,MAAF,EAAc;AAE/B,YAAMC,UAAU,GAAG;AAClBC,UAAAA,YAAY,EAAE,MAAI,CAACtB,mBADD;AAElBuB,UAAAA,cAAc,EAAE,MAAI,CAAClB,qBAFH;AAGlBmB,UAAAA,YAAY,EAAE;AAHI,SAAnB;;AAMA,QAAA,MAAI,CAACC,cAAL,CAAqBL,MAArB,EAA6BC,UAA7B,EACEK,IADF,CACQjB,MADR,EAEEkB,KAFF,CAEShB,OAFT;AAIA,OAZD,EAYGD,UAZH,EAYeC,OAZf;AAcA;AAED;;;;WACA,yBAAiBS,MAAjB,EAAyBQ,QAAzB,EAAmCN,YAAnC,EAAiDC,cAAjD,EAAkE;AAEjE,UAAMF,UAAU,GAAG;AAClBC,QAAAA,YAAY,EAAEA,YAAY,IAAI,KAAKtB,mBADjB;AAElBuB,QAAAA,cAAc,EAAEA,cAAc,IAAI,KAAKlB,qBAFrB;AAGlBmB,QAAAA,YAAY,EAAE,CAAC,CAAEF;AAHC,OAAnB;AAMA,WAAKG,cAAL,CAAqBL,MAArB,EAA6BC,UAA7B,EAA0CK,IAA1C,CAAgDE,QAAhD;AAEA;;;WAED,wBAAgBR,MAAhB,EAAwBC,UAAxB,EAAqC;AAAA;;AAEpC;AACA;AACA;AACA,WAAM,IAAMQ,SAAZ,IAAyBR,UAAU,CAACE,cAApC,EAAqD;AAEpD,YAAMO,IAAI,GAAGT,UAAU,CAACE,cAAX,CAA2BM,SAA3B,CAAb;;AAEA,YAAKC,IAAI,CAACC,iBAAL,KAA2BC,SAAhC,EAA4C;AAE3CX,UAAAA,UAAU,CAACE,cAAX,CAA2BM,SAA3B,IAAyCC,IAAI,CAACG,IAA9C;AAEA;AAED,OAfmC,CAiBpC;;;AAEA,UAAMC,OAAO,GAAGC,IAAI,CAACC,SAAL,CAAgBf,UAAhB,CAAhB,CAnBoC,CAqBpC;AACA;;AACA,UAAKjC,UAAU,CAACiD,GAAX,CAAgBjB,MAAhB,CAAL,EAAgC;AAE/B,YAAMkB,UAAU,GAAGlD,UAAU,CAACmD,GAAX,CAAgBnB,MAAhB,CAAnB;;AAEA,YAAKkB,UAAU,CAACE,GAAX,KAAmBN,OAAxB,EAAkC;AAEjC,iBAAOI,UAAU,CAACG,OAAlB;AAEA,SAJD,MAIO,IAAKrB,MAAM,CAACsB,UAAP,KAAsB,CAA3B,EAA+B;AAErC;AACA;AACA;AACA;AACA,gBAAM,IAAIC,KAAJ,CAEL,oEACA,gDAHK,CAAN;AAOA;AAED,OA9CmC,CAgDpC;;;AAEA,UAAIC,MAAJ;AACA,UAAMC,MAAM,GAAG,KAAK/C,gBAAL,EAAf;AACA,UAAMgD,QAAQ,GAAG1B,MAAM,CAACsB,UAAxB,CApDoC,CAsDpC;AACA;;AACA,UAAMK,eAAe,GAAG,KAAKC,UAAL,CAAiBH,MAAjB,EAAyBC,QAAzB,EACtBpB,IADsB,CAChB,UAAEuB,OAAF,EAAe;AAErBL,QAAAA,MAAM,GAAGK,OAAT;AAEA,eAAO,IAAIC,OAAJ,CAAa,UAAEC,OAAF,EAAWC,MAAX,EAAuB;AAE1CR,UAAAA,MAAM,CAACS,UAAP,CAAmBR,MAAnB,IAA8B;AAAEM,YAAAA,OAAO,EAAPA,OAAF;AAAWC,YAAAA,MAAM,EAANA;AAAX,WAA9B;AAEAR,UAAAA,MAAM,CAACU,WAAP,CAAoB;AAAExB,YAAAA,IAAI,EAAE,QAAR;AAAkByB,YAAAA,EAAE,EAAEV,MAAtB;AAA8BxB,YAAAA,UAAU,EAAVA,UAA9B;AAA0CD,YAAAA,MAAM,EAANA;AAA1C,WAApB,EAAwE,CAAEA,MAAF,CAAxE,EAJ0C,CAM1C;AAEA,SARM,CAAP;AAUA,OAfsB,EAgBtBM,IAhBsB,CAgBhB,UAAE8B,OAAF;AAAA,eAAe,MAAI,CAACC,eAAL,CAAsBD,OAAO,CAACE,QAA9B,CAAf;AAAA,OAhBgB,CAAxB,CAxDoC,CA0EpC;AACA;;;AACAX,MAAAA,eAAe,CACbpB,KADF,CACS;AAAA,eAAM,IAAN;AAAA,OADT,EAEED,IAFF,CAEQ,YAAM;AAEZ,YAAKkB,MAAM,IAAIC,MAAf,EAAwB;AAEvB,UAAA,MAAI,CAACc,YAAL,CAAmBf,MAAnB,EAA2BC,MAA3B,EAFuB,CAIvB;;AAEA;AAED,OAZF,EA5EoC,CA0FpC;;AACAzD,MAAAA,UAAU,CAACwE,GAAX,CAAgBxC,MAAhB,EAAwB;AAEvBoB,QAAAA,GAAG,EAAEN,OAFkB;AAGvBO,QAAAA,OAAO,EAAEM;AAHc,OAAxB;;AAOA,aAAOA,eAAP;AAEA;;;WAED,yBAAiBc,YAAjB,EAAgC;AAE/B,UAAMH,QAAQ,GAAG,IAAIzE,cAAJ,EAAjB;;AAEA,UAAK4E,YAAY,CAACC,KAAlB,EAA0B;AAEzBJ,QAAAA,QAAQ,CAACK,QAAT,CAAmB,IAAI/E,eAAJ,CAAqB6E,YAAY,CAACC,KAAb,CAAmBE,KAAxC,EAA+C,CAA/C,CAAnB;AAEA;;AAED,WAAM,IAAIC,CAAC,GAAG,CAAd,EAAiBA,CAAC,GAAGJ,YAAY,CAACK,UAAb,CAAwBC,MAA7C,EAAqDF,CAAC,EAAtD,EAA4D;AAE3D,YAAMpC,SAAS,GAAGgC,YAAY,CAACK,UAAb,CAAyBD,CAAzB,CAAlB;AACA,YAAMhC,IAAI,GAAGJ,SAAS,CAACI,IAAvB;AACA,YAAM+B,KAAK,GAAGnC,SAAS,CAACmC,KAAxB;AACA,YAAMI,QAAQ,GAAGvC,SAAS,CAACuC,QAA3B;AAEAV,QAAAA,QAAQ,CAACW,YAAT,CAAuBpC,IAAvB,EAA6B,IAAIjD,eAAJ,CAAqBgF,KAArB,EAA4BI,QAA5B,CAA7B;AAEA;;AAED,aAAOV,QAAP;AAEA;;;WAED,sBAAclD,GAAd,EAAmB8D,YAAnB,EAAkC;AAEjC,UAAM1D,MAAM,GAAG,IAAI1B,UAAJ,CAAgB,KAAKK,OAArB,CAAf;AACAqB,MAAAA,MAAM,CAACC,OAAP,CAAgB,KAAKrB,WAArB;AACAoB,MAAAA,MAAM,CAACE,eAAP,CAAwBwD,YAAxB;AACA1D,MAAAA,MAAM,CAACK,kBAAP,CAA2B,KAAKC,eAAhC;AAEA,aAAO,IAAIgC,OAAJ,CAAa,UAAEC,OAAF,EAAWC,MAAX,EAAuB;AAE1CxC,QAAAA,MAAM,CAACO,IAAP,CAAaX,GAAb,EAAkB2C,OAAlB,EAA2BnB,SAA3B,EAAsCoB,MAAtC;AAEA,OAJM,CAAP;AAMA;;;WAED,mBAAU;AAET,WAAKmB,YAAL;;AAEA,aAAO,IAAP;AAEA;;;WAED,wBAAe;AAAA;;AAEd,UAAK,KAAK5E,cAAV,EAA2B,OAAO,KAAKA,cAAZ;AAE3B,UAAM6E,KAAK,GAAG,OAAOC,WAAP,KAAuB,QAAvB,IAAmC,KAAKhF,aAAL,CAAmBqC,IAAnB,KAA4B,IAA7E;AACA,UAAM4C,gBAAgB,GAAG,EAAzB;;AAEA,UAAKF,KAAL,EAAa;AAEZE,QAAAA,gBAAgB,CAACC,IAAjB,CAAuB,KAAKC,YAAL,CAAmB,kBAAnB,EAAuC,MAAvC,CAAvB;AAEA,OAJD,MAIO;AAENF,QAAAA,gBAAgB,CAACC,IAAjB,CAAuB,KAAKC,YAAL,CAAmB,uBAAnB,EAA4C,MAA5C,CAAvB;AACAF,QAAAA,gBAAgB,CAACC,IAAjB,CAAuB,KAAKC,YAAL,CAAmB,oBAAnB,EAAyC,aAAzC,CAAvB;AAEA;;AAED,WAAKjF,cAAL,GAAsBuD,OAAO,CAAC2B,GAAR,CAAaH,gBAAb,EACpBhD,IADoB,CACd,UAAEoD,SAAF,EAAiB;AAEvB,YAAMC,SAAS,GAAGD,SAAS,CAAE,CAAF,CAA3B;;AAEA,YAAK,CAAEN,KAAP,EAAe;AAEd,UAAA,MAAI,CAAC/E,aAAL,CAAmBuF,UAAnB,GAAgCF,SAAS,CAAE,CAAF,CAAzC;AAEA;;AAED,YAAMG,EAAE,GAAGC,WAAW,CAACC,QAAZ,EAAX;AAEA,YAAMC,IAAI,GAAG,CACZ,qBADY,EAEZL,SAFY,EAGZ,EAHY,EAIZ,cAJY,EAKZE,EAAE,CAACI,SAAH,CAAcJ,EAAE,CAACK,OAAH,CAAY,GAAZ,IAAoB,CAAlC,EAAqCL,EAAE,CAACM,WAAH,CAAgB,GAAhB,CAArC,CALY,EAMXC,IANW,CAML,IANK,CAAb;AAQA,QAAA,MAAI,CAACzF,eAAL,GAAuB0F,GAAG,CAACC,eAAJ,CAAqB,IAAIC,IAAJ,CAAU,CAAEP,IAAF,CAAV,CAArB,CAAvB;AAEA,OAvBoB,CAAtB;AAyBA,aAAO,KAAKzF,cAAZ;AAEA;;;WAED,oBAAYkD,MAAZ,EAAoBC,QAApB,EAA+B;AAAA;;AAE9B,aAAO,KAAKyB,YAAL,GAAoB7C,IAApB,CAA0B,YAAM;AAEtC,YAAK,MAAI,CAAC7B,UAAL,CAAgBsE,MAAhB,GAAyB,MAAI,CAACvE,WAAnC,EAAiD;AAEhD,cAAMgD,QAAM,GAAG,IAAIgD,MAAJ,CAAY,MAAI,CAAC7F,eAAjB,CAAf;;AAEA6C,UAAAA,QAAM,CAACS,UAAP,GAAoB,EAApB;AACAT,UAAAA,QAAM,CAACiD,UAAP,GAAoB,EAApB;AACAjD,UAAAA,QAAM,CAACkD,SAAP,GAAmB,CAAnB;;AAEAlD,UAAAA,QAAM,CAACU,WAAP,CAAoB;AAAExB,YAAAA,IAAI,EAAE,MAAR;AAAgBrC,YAAAA,aAAa,EAAE,MAAI,CAACA;AAApC,WAApB;;AAEAmD,UAAAA,QAAM,CAACmD,SAAP,GAAmB,UAAWC,CAAX,EAAe;AAEjC,gBAAMxC,OAAO,GAAGwC,CAAC,CAACC,IAAlB;;AAEA,oBAASzC,OAAO,CAAC1B,IAAjB;AAEC,mBAAK,QAAL;AACCc,gBAAAA,QAAM,CAACS,UAAP,CAAmBG,OAAO,CAACD,EAA3B,EAAgCJ,OAAhC,CAAyCK,OAAzC;;AACA;;AAED,mBAAK,OAAL;AACCZ,gBAAAA,QAAM,CAACS,UAAP,CAAmBG,OAAO,CAACD,EAA3B,EAAgCH,MAAhC,CAAwCI,OAAxC;;AACA;;AAED;AACC0C,gBAAAA,OAAO,CAACC,KAAR,CAAe,6CAA6C3C,OAAO,CAAC1B,IAArD,GAA4D,GAA3E;AAXF;AAeA,WAnBD;;AAqBA,UAAA,MAAI,CAACjC,UAAL,CAAgB8E,IAAhB,CAAsB/B,QAAtB;AAEA,SAjCD,MAiCO;AAEN,UAAA,MAAI,CAAC/C,UAAL,CAAgBuG,IAAhB,CAAsB,UAAWC,CAAX,EAAcC,CAAd,EAAkB;AAEvC,mBAAOD,CAAC,CAACP,SAAF,GAAcQ,CAAC,CAACR,SAAhB,GAA4B,CAAE,CAA9B,GAAkC,CAAzC;AAEA,WAJD;AAMA;;AAED,YAAMlD,MAAM,GAAG,MAAI,CAAC/C,UAAL,CAAiB,MAAI,CAACA,UAAL,CAAgBsE,MAAhB,GAAyB,CAA1C,CAAf;AACAvB,QAAAA,MAAM,CAACiD,UAAP,CAAmBhD,MAAnB,IAA8BC,QAA9B;AACAF,QAAAA,MAAM,CAACkD,SAAP,IAAoBhD,QAApB;AACA,eAAOF,MAAP;AAEA,OAlDM,CAAP;AAoDA;;;WAED,sBAAcA,MAAd,EAAsBC,MAAtB,EAA+B;AAE9BD,MAAAA,MAAM,CAACkD,SAAP,IAAoBlD,MAAM,CAACiD,UAAP,CAAmBhD,MAAnB,CAApB;AACA,aAAOD,MAAM,CAACS,UAAP,CAAmBR,MAAnB,CAAP;AACA,aAAOD,MAAM,CAACiD,UAAP,CAAmBhD,MAAnB,CAAP;AAEA;;;WAED,iBAAQ;AAEPqD,MAAAA,OAAO,CAACK,GAAR,CAAa,aAAb,EAA4B,KAAK1G,UAAL,CAAgB2G,GAAhB,CAAqB,UAAE5D,MAAF;AAAA,eAAcA,MAAM,CAACkD,SAArB;AAAA,OAArB,CAA5B;AAEA;;;WAED,mBAAU;AAET,WAAM,IAAI7B,CAAC,GAAG,CAAd,EAAiBA,CAAC,GAAG,KAAKpE,UAAL,CAAgBsE,MAArC,EAA6C,EAAGF,CAAhD,EAAoD;AAEnD,aAAKpE,UAAL,CAAiBoE,CAAjB,EAAqBwC,SAArB;AAEA;;AAED,WAAK5G,UAAL,CAAgBsE,MAAhB,GAAyB,CAAzB;AAEA,aAAO,IAAP;AAEA;;;;EApXwBhF,M;AAwX1B;;;AAEA,SAAS+F,WAAT,GAAuB;AAEtB,MAAIzF,aAAJ;AACA,MAAIE,cAAJ;;AAEAoG,EAAAA,SAAS,GAAG,mBAAWC,CAAX,EAAe;AAE1B,QAAMxC,OAAO,GAAGwC,CAAC,CAACC,IAAlB;;AAEA,YAASzC,OAAO,CAAC1B,IAAjB;AAEC,WAAK,MAAL;AACCrC,QAAAA,aAAa,GAAG+D,OAAO,CAAC/D,aAAxB;AACAE,QAAAA,cAAc,GAAG,IAAIuD,OAAJ,CAAa,UAAWC;AAAO;AAAlB,UAAiC;AAE9D1D,UAAAA,aAAa,CAACiH,cAAd,GAA+B,UAAWC,KAAX,EAAmB;AAEjD;AACAxD,YAAAA,OAAO,CAAE;AAAEwD,cAAAA,KAAK,EAAEA;AAAT,aAAF,CAAP;AAEA,WALD;;AAOAC,UAAAA,kBAAkB,CAAEnH,aAAF,CAAlB,CAT8D,CASzB;AAErC,SAXgB,CAAjB;AAYA;;AAED,WAAK,QAAL;AACC,YAAM2B,MAAM,GAAGoC,OAAO,CAACpC,MAAvB;AACA,YAAMC,UAAU,GAAGmC,OAAO,CAACnC,UAA3B;AACA1B,QAAAA,cAAc,CAAC+B,IAAf,CAAqB,UAAEmF,MAAF,EAAc;AAElC,cAAMF,KAAK,GAAGE,MAAM,CAACF,KAArB;AACA,cAAMG,OAAO,GAAG,IAAIH,KAAK,CAACI,OAAV,EAAhB;AACA,cAAMC,aAAa,GAAG,IAAIL,KAAK,CAACM,aAAV,EAAtB;AACAD,UAAAA,aAAa,CAACE,IAAd,CAAoB,IAAIC,SAAJ,CAAe/F,MAAf,CAApB,EAA6CA,MAAM,CAACsB,UAApD;;AAEA,cAAI;AAEH,gBAAMgB,QAAQ,GAAGjC,cAAc,CAAEkF,KAAF,EAASG,OAAT,EAAkBE,aAAlB,EAAiC3F,UAAjC,CAA/B;AAEA,gBAAM+F,OAAO,GAAG1D,QAAQ,CAACQ,UAAT,CAAoBsC,GAApB,CAAyB,UAAEa,IAAF;AAAA,qBAAYA,IAAI,CAACrD,KAAL,CAAW5C,MAAvB;AAAA,aAAzB,CAAhB;AAEA,gBAAKsC,QAAQ,CAACI,KAAd,EAAsBsD,OAAO,CAACzC,IAAR,CAAcjB,QAAQ,CAACI,KAAT,CAAeE,KAAf,CAAqB5C,MAAnC;AAEtBkG,YAAAA,IAAI,CAAChE,WAAL,CAAkB;AAAExB,cAAAA,IAAI,EAAE,QAAR;AAAkByB,cAAAA,EAAE,EAAEC,OAAO,CAACD,EAA9B;AAAkCG,cAAAA,QAAQ,EAARA;AAAlC,aAAlB,EAAgE0D,OAAhE;AAEA,WAVD,CAUE,OAAQjB,KAAR,EAAgB;AAEjBD,YAAAA,OAAO,CAACC,KAAR,CAAeA,KAAf;AAEAmB,YAAAA,IAAI,CAAChE,WAAL,CAAkB;AAAExB,cAAAA,IAAI,EAAE,OAAR;AAAiByB,cAAAA,EAAE,EAAEC,OAAO,CAACD,EAA7B;AAAiC4C,cAAAA,KAAK,EAAEA,KAAK,CAAC3C;AAA9C,aAAlB;AAEA,WAhBD,SAgBU;AAETmD,YAAAA,KAAK,CAACY,OAAN,CAAeP,aAAf;AACAL,YAAAA,KAAK,CAACY,OAAN,CAAeT,OAAf;AAEA;AAED,SA9BD;AA+BA;AApDF;AAwDA,GA5DD;;AA8DA,WAASrF,cAAT,CAAyBkF,KAAzB,EAAgCG,OAAhC,EAAyCE,aAAzC,EAAwD3F,UAAxD,EAAqE;AAEpE,QAAMC,YAAY,GAAGD,UAAU,CAACC,YAAhC;AACA,QAAMC,cAAc,GAAGF,UAAU,CAACE,cAAlC;AAEA,QAAIiG,aAAJ;AACA,QAAIC,cAAJ;AAEA,QAAMC,YAAY,GAAGZ,OAAO,CAACa,sBAAR,CAAgCX,aAAhC,CAArB;;AAEA,QAAKU,YAAY,KAAKf,KAAK,CAACiB,eAA5B,EAA8C;AAE7CJ,MAAAA,aAAa,GAAG,IAAIb,KAAK,CAACkB,IAAV,EAAhB;AACAJ,MAAAA,cAAc,GAAGX,OAAO,CAACgB,kBAAR,CAA4Bd,aAA5B,EAA2CQ,aAA3C,CAAjB;AAEA,KALD,MAKO,IAAKE,YAAY,KAAKf,KAAK,CAACoB,WAA5B,EAA0C;AAEhDP,MAAAA,aAAa,GAAG,IAAIb,KAAK,CAACqB,UAAV,EAAhB;AACAP,MAAAA,cAAc,GAAGX,OAAO,CAACmB,wBAAR,CAAkCjB,aAAlC,EAAiDQ,aAAjD,CAAjB;AAEA,KALM,MAKA;AAEN,YAAM,IAAI7E,KAAJ,CAAW,8CAAX,CAAN;AAEA;;AAED,QAAK,CAAE8E,cAAc,CAACS,EAAf,EAAF,IAAyBV,aAAa,CAACW,GAAd,KAAsB,CAApD,EAAwD;AAEvD,YAAM,IAAIxF,KAAJ,CAAW,yCAAyC8E,cAAc,CAACW,SAAf,EAApD,CAAN;AAEA;;AAED,QAAM1E,QAAQ,GAAG;AAAEI,MAAAA,KAAK,EAAE,IAAT;AAAeI,MAAAA,UAAU,EAAE;AAA3B,KAAjB,CAhCoE,CAkCpE;;AACA,SAAM,IAAMmE,aAAZ,IAA6B/G,YAA7B,EAA4C;AAE3C,UAAMgH,aAAa,GAAGhB,IAAI,CAAE/F,cAAc,CAAE8G,aAAF,CAAhB,CAA1B;AAEA,UAAIxG,SAAS,SAAb;AACA,UAAI0G,WAAW,SAAf,CAL2C,CAO3C;AACA;AACA;AACA;;AACA,UAAKlH,UAAU,CAACG,YAAhB,EAA+B;AAE9B+G,QAAAA,WAAW,GAAGjH,YAAY,CAAE+G,aAAF,CAA1B;AACAxG,QAAAA,SAAS,GAAGiF,OAAO,CAAC0B,sBAAR,CAAgChB,aAAhC,EAA+Ce,WAA/C,CAAZ;AAEA,OALD,MAKO;AAENA,QAAAA,WAAW,GAAGzB,OAAO,CAAC2B,cAAR,CAAwBjB,aAAxB,EAAuCb,KAAK,CAAErF,YAAY,CAAE+G,aAAF,CAAd,CAA5C,CAAd;AAEA,YAAKE,WAAW,KAAK,CAAE,CAAvB,EAA2B;AAE3B1G,QAAAA,SAAS,GAAGiF,OAAO,CAAC4B,YAAR,CAAsBlB,aAAtB,EAAqCe,WAArC,CAAZ;AAEA;;AAED7E,MAAAA,QAAQ,CAACQ,UAAT,CAAoBS,IAApB,CAA0BgE,eAAe,CAAEhC,KAAF,EAASG,OAAT,EAAkBU,aAAlB,EAAiCa,aAAjC,EAAgDC,aAAhD,EAA+DzG,SAA/D,CAAzC;AAEA,KA/DmE,CAiEpE;;;AACA,QAAK6F,YAAY,KAAKf,KAAK,CAACiB,eAA5B,EAA8C;AAE7ClE,MAAAA,QAAQ,CAACI,KAAT,GAAiB8E,WAAW,CAAEjC,KAAF,EAASG,OAAT,EAAkBU,aAAlB,CAA5B;AAEA;;AAEDb,IAAAA,KAAK,CAACY,OAAN,CAAeC,aAAf;AAEA,WAAO9D,QAAP;AAEA;;AAED,WAASkF,WAAT,CAAsBjC,KAAtB,EAA6BG,OAA7B,EAAsCU,aAAtC,EAAsD;AAErD,QAAMqB,QAAQ,GAAGrB,aAAa,CAACsB,SAAd,EAAjB;AACA,QAAMC,UAAU,GAAGF,QAAQ,GAAG,CAA9B;AACA,QAAMnG,UAAU,GAAGqG,UAAU,GAAG,CAAhC;;AAEA,QAAMZ,GAAG,GAAGxB,KAAK,CAACqC,OAAN,CAAetG,UAAf,CAAZ;;AACAoE,IAAAA,OAAO,CAACmC,uBAAR,CAAiCzB,aAAjC,EAAgD9E,UAAhD,EAA4DyF,GAA5D;AACA,QAAMrE,KAAK,GAAG,IAAIoF,WAAJ,CAAiBvC,KAAK,CAACwC,OAAN,CAAc/H,MAA/B,EAAuC+G,GAAvC,EAA4CY,UAA5C,EAAyDK,KAAzD,EAAd;;AACAzC,IAAAA,KAAK,CAAC0C,KAAN,CAAalB,GAAb;;AAEA,WAAO;AAAEnE,MAAAA,KAAK,EAAEF,KAAT;AAAgBM,MAAAA,QAAQ,EAAE;AAA1B,KAAP;AAEA;;AAED,WAASuE,eAAT,CAA0BhC,KAA1B,EAAiCG,OAAjC,EAA0CU,aAA1C,EAAyDa,aAAzD,EAAwEC,aAAxE,EAAuFzG,SAAvF,EAAmG;AAElG,QAAMyH,aAAa,GAAGzH,SAAS,CAAC0H,cAAV,EAAtB;AACA,QAAMC,SAAS,GAAGhC,aAAa,CAACiC,UAAd,EAAlB;AACA,QAAMC,SAAS,GAAGF,SAAS,GAAGF,aAA9B;AACA,QAAM5G,UAAU,GAAGgH,SAAS,GAAGpB,aAAa,CAACvG,iBAA7C;AACA,QAAM4H,QAAQ,GAAGC,gBAAgB,CAAEjD,KAAF,EAAS2B,aAAT,CAAjC;;AAEA,QAAMH,GAAG,GAAGxB,KAAK,CAACqC,OAAN,CAAetG,UAAf,CAAZ;;AACAoE,IAAAA,OAAO,CAAC+C,iCAAR,CAA2CrC,aAA3C,EAA0D3F,SAA1D,EAAqE8H,QAArE,EAA+EjH,UAA/E,EAA2FyF,GAA3F;AACA,QAAMnE,KAAK,GAAG,IAAIsE,aAAJ,CAAmB3B,KAAK,CAACwC,OAAN,CAAc/H,MAAjC,EAAyC+G,GAAzC,EAA8CuB,SAA9C,EAA0DN,KAA1D,EAAd;;AACAzC,IAAAA,KAAK,CAAC0C,KAAN,CAAalB,GAAb;;AAEA,WAAO;AACNlG,MAAAA,IAAI,EAAEoG,aADA;AAENrE,MAAAA,KAAK,EAAEA,KAFD;AAGNI,MAAAA,QAAQ,EAAEkF;AAHJ,KAAP;AAMA;;AAED,WAASM,gBAAT,CAA2BjD,KAA3B,EAAkC2B,aAAlC,EAAkD;AAEjD,YAASA,aAAT;AAEC,WAAKwB,YAAL;AAAmB,eAAOnD,KAAK,CAACoD,UAAb;;AACnB,WAAK5C,SAAL;AAAgB,eAAOR,KAAK,CAACqD,OAAb;;AAChB,WAAKC,UAAL;AAAiB,eAAOtD,KAAK,CAACuD,QAAb;;AACjB,WAAKC,UAAL;AAAiB,eAAOxD,KAAK,CAACyD,QAAb;;AACjB,WAAKC,UAAL;AAAiB,eAAO1D,KAAK,CAAC2D,QAAb;;AACjB,WAAKC,WAAL;AAAkB,eAAO5D,KAAK,CAAC6D,SAAb;;AAClB,WAAKtB,WAAL;AAAkB,eAAOvC,KAAK,CAAC8D,SAAb;AARnB;AAYA;AAED;;AAED,SAASnL,WAAT","sourcesContent":["import {\n\tBufferAttribute,\n\tBufferGeometry,\n\tFileLoader,\n\tLoader\n} from 'three';\n\nconst _taskCache = new WeakMap();\n\nclass DRACOLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t\tthis.decoderPath = '';\n\t\tthis.decoderConfig = {};\n\t\tthis.decoderBinary = null;\n\t\tthis.decoderPending = null;\n\n\t\tthis.workerLimit = 4;\n\t\tthis.workerPool = [];\n\t\tthis.workerNextTaskID = 1;\n\t\tthis.workerSourceURL = '';\n\n\t\tthis.defaultAttributeIDs = {\n\t\t\tposition: 'POSITION',\n\t\t\tnormal: 'NORMAL',\n\t\t\tcolor: 'COLOR',\n\t\t\tuv: 'TEX_COORD'\n\t\t};\n\t\tthis.defaultAttributeTypes = {\n\t\t\tposition: 'Float32Array',\n\t\t\tnormal: 'Float32Array',\n\t\t\tcolor: 'Float32Array',\n\t\t\tuv: 'Float32Array'\n\t\t};\n\n\t}\n\n\tsetDecoderPath( path ) {\n\n\t\tthis.decoderPath = path;\n\n\t\treturn this;\n\n\t}\n\n\tsetDecoderConfig( config ) {\n\n\t\tthis.decoderConfig = config;\n\n\t\treturn this;\n\n\t}\n\n\tsetWorkerLimit( workerLimit ) {\n\n\t\tthis.workerLimit = workerLimit;\n\n\t\treturn this;\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst loader = new FileLoader( this.manager );\n\n\t\tloader.setPath( this.path );\n\t\tloader.setResponseType( 'arraybuffer' );\n\t\tloader.setRequestHeader( this.requestHeader );\n\t\tloader.setWithCredentials( this.withCredentials );\n\n\t\tloader.load( url, ( buffer ) => {\n\n\t\t\tconst taskConfig = {\n\t\t\t\tattributeIDs: this.defaultAttributeIDs,\n\t\t\t\tattributeTypes: this.defaultAttributeTypes,\n\t\t\t\tuseUniqueIDs: false\n\t\t\t};\n\n\t\t\tthis.decodeGeometry( buffer, taskConfig )\n\t\t\t\t.then( onLoad )\n\t\t\t\t.catch( onError );\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\t/** @deprecated Kept for backward-compatibility with previous DRACOLoader versions. */\n\tdecodeDracoFile( buffer, callback, attributeIDs, attributeTypes ) {\n\n\t\tconst taskConfig = {\n\t\t\tattributeIDs: attributeIDs || this.defaultAttributeIDs,\n\t\t\tattributeTypes: attributeTypes || this.defaultAttributeTypes,\n\t\t\tuseUniqueIDs: !! attributeIDs\n\t\t};\n\n\t\tthis.decodeGeometry( buffer, taskConfig ).then( callback );\n\n\t}\n\n\tdecodeGeometry( buffer, taskConfig ) {\n\n\t\t// TODO: For backward-compatibility, support 'attributeTypes' objects containing\n\t\t// references (rather than names) to typed array constructors. These must be\n\t\t// serialized before sending them to the worker.\n\t\tfor ( const attribute in taskConfig.attributeTypes ) {\n\n\t\t\tconst type = taskConfig.attributeTypes[ attribute ];\n\n\t\t\tif ( type.BYTES_PER_ELEMENT !== undefined ) {\n\n\t\t\t\ttaskConfig.attributeTypes[ attribute ] = type.name;\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tconst taskKey = JSON.stringify( taskConfig );\n\n\t\t// Check for an existing task using this buffer. A transferred buffer cannot be transferred\n\t\t// again from this thread.\n\t\tif ( _taskCache.has( buffer ) ) {\n\n\t\t\tconst cachedTask = _taskCache.get( buffer );\n\n\t\t\tif ( cachedTask.key === taskKey ) {\n\n\t\t\t\treturn cachedTask.promise;\n\n\t\t\t} else if ( buffer.byteLength === 0 ) {\n\n\t\t\t\t// Technically, it would be possible to wait for the previous task to complete,\n\t\t\t\t// transfer the buffer back, and decode again with the second configuration. That\n\t\t\t\t// is complex, and I don't know of any reason to decode a Draco buffer twice in\n\t\t\t\t// different ways, so this is left unimplemented.\n\t\t\t\tthrow new Error(\n\n\t\t\t\t\t'THREE.DRACOLoader: Unable to re-decode a buffer with different ' +\n\t\t\t\t\t'settings. Buffer has already been transferred.'\n\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tlet worker;\n\t\tconst taskID = this.workerNextTaskID ++;\n\t\tconst taskCost = buffer.byteLength;\n\n\t\t// Obtain a worker and assign a task, and construct a geometry instance\n\t\t// when the task completes.\n\t\tconst geometryPending = this._getWorker( taskID, taskCost )\n\t\t\t.then( ( _worker ) => {\n\n\t\t\t\tworker = _worker;\n\n\t\t\t\treturn new Promise( ( resolve, reject ) => {\n\n\t\t\t\t\tworker._callbacks[ taskID ] = { resolve, reject };\n\n\t\t\t\t\tworker.postMessage( { type: 'decode', id: taskID, taskConfig, buffer }, [ buffer ] );\n\n\t\t\t\t\t// this.debug();\n\n\t\t\t\t} );\n\n\t\t\t} )\n\t\t\t.then( ( message ) => this._createGeometry( message.geometry ) );\n\n\t\t// Remove task from the task list.\n\t\t// Note: replaced '.finally()' with '.catch().then()' block - iOS 11 support (#19416)\n\t\tgeometryPending\n\t\t\t.catch( () => true )\n\t\t\t.then( () => {\n\n\t\t\t\tif ( worker && taskID ) {\n\n\t\t\t\t\tthis._releaseTask( worker, taskID );\n\n\t\t\t\t\t// this.debug();\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t// Cache the task result.\n\t\t_taskCache.set( buffer, {\n\n\t\t\tkey: taskKey,\n\t\t\tpromise: geometryPending\n\n\t\t} );\n\n\t\treturn geometryPending;\n\n\t}\n\n\t_createGeometry( geometryData ) {\n\n\t\tconst geometry = new BufferGeometry();\n\n\t\tif ( geometryData.index ) {\n\n\t\t\tgeometry.setIndex( new BufferAttribute( geometryData.index.array, 1 ) );\n\n\t\t}\n\n\t\tfor ( let i = 0; i < geometryData.attributes.length; i ++ ) {\n\n\t\t\tconst attribute = geometryData.attributes[ i ];\n\t\t\tconst name = attribute.name;\n\t\t\tconst array = attribute.array;\n\t\t\tconst itemSize = attribute.itemSize;\n\n\t\t\tgeometry.setAttribute( name, new BufferAttribute( array, itemSize ) );\n\n\t\t}\n\n\t\treturn geometry;\n\n\t}\n\n\t_loadLibrary( url, responseType ) {\n\n\t\tconst loader = new FileLoader( this.manager );\n\t\tloader.setPath( this.decoderPath );\n\t\tloader.setResponseType( responseType );\n\t\tloader.setWithCredentials( this.withCredentials );\n\n\t\treturn new Promise( ( resolve, reject ) => {\n\n\t\t\tloader.load( url, resolve, undefined, reject );\n\n\t\t} );\n\n\t}\n\n\tpreload() {\n\n\t\tthis._initDecoder();\n\n\t\treturn this;\n\n\t}\n\n\t_initDecoder() {\n\n\t\tif ( this.decoderPending ) return this.decoderPending;\n\n\t\tconst useJS = typeof WebAssembly !== 'object' || this.decoderConfig.type === 'js';\n\t\tconst librariesPending = [];\n\n\t\tif ( useJS ) {\n\n\t\t\tlibrariesPending.push( this._loadLibrary( 'draco_decoder.js', 'text' ) );\n\n\t\t} else {\n\n\t\t\tlibrariesPending.push( this._loadLibrary( 'draco_wasm_wrapper.js', 'text' ) );\n\t\t\tlibrariesPending.push( this._loadLibrary( 'draco_decoder.wasm', 'arraybuffer' ) );\n\n\t\t}\n\n\t\tthis.decoderPending = Promise.all( librariesPending )\n\t\t\t.then( ( libraries ) => {\n\n\t\t\t\tconst jsContent = libraries[ 0 ];\n\n\t\t\t\tif ( ! useJS ) {\n\n\t\t\t\t\tthis.decoderConfig.wasmBinary = libraries[ 1 ];\n\n\t\t\t\t}\n\n\t\t\t\tconst fn = DRACOWorker.toString();\n\n\t\t\t\tconst body = [\n\t\t\t\t\t'/* draco decoder */',\n\t\t\t\t\tjsContent,\n\t\t\t\t\t'',\n\t\t\t\t\t'/* worker */',\n\t\t\t\t\tfn.substring( fn.indexOf( '{' ) + 1, fn.lastIndexOf( '}' ) )\n\t\t\t\t].join( '\\n' );\n\n\t\t\t\tthis.workerSourceURL = URL.createObjectURL( new Blob( [ body ] ) );\n\n\t\t\t} );\n\n\t\treturn this.decoderPending;\n\n\t}\n\n\t_getWorker( taskID, taskCost ) {\n\n\t\treturn this._initDecoder().then( () => {\n\n\t\t\tif ( this.workerPool.length < this.workerLimit ) {\n\n\t\t\t\tconst worker = new Worker( this.workerSourceURL );\n\n\t\t\t\tworker._callbacks = {};\n\t\t\t\tworker._taskCosts = {};\n\t\t\t\tworker._taskLoad = 0;\n\n\t\t\t\tworker.postMessage( { type: 'init', decoderConfig: this.decoderConfig } );\n\n\t\t\t\tworker.onmessage = function ( e ) {\n\n\t\t\t\t\tconst message = e.data;\n\n\t\t\t\t\tswitch ( message.type ) {\n\n\t\t\t\t\t\tcase 'decode':\n\t\t\t\t\t\t\tworker._callbacks[ message.id ].resolve( message );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'error':\n\t\t\t\t\t\t\tworker._callbacks[ message.id ].reject( message );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.error( 'THREE.DRACOLoader: Unexpected message, \"' + message.type + '\"' );\n\n\t\t\t\t\t}\n\n\t\t\t\t};\n\n\t\t\t\tthis.workerPool.push( worker );\n\n\t\t\t} else {\n\n\t\t\t\tthis.workerPool.sort( function ( a, b ) {\n\n\t\t\t\t\treturn a._taskLoad > b._taskLoad ? - 1 : 1;\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tconst worker = this.workerPool[ this.workerPool.length - 1 ];\n\t\t\tworker._taskCosts[ taskID ] = taskCost;\n\t\t\tworker._taskLoad += taskCost;\n\t\t\treturn worker;\n\n\t\t} );\n\n\t}\n\n\t_releaseTask( worker, taskID ) {\n\n\t\tworker._taskLoad -= worker._taskCosts[ taskID ];\n\t\tdelete worker._callbacks[ taskID ];\n\t\tdelete worker._taskCosts[ taskID ];\n\n\t}\n\n\tdebug() {\n\n\t\tconsole.log( 'Task load: ', this.workerPool.map( ( worker ) => worker._taskLoad ) );\n\n\t}\n\n\tdispose() {\n\n\t\tfor ( let i = 0; i < this.workerPool.length; ++ i ) {\n\n\t\t\tthis.workerPool[ i ].terminate();\n\n\t\t}\n\n\t\tthis.workerPool.length = 0;\n\n\t\treturn this;\n\n\t}\n\n}\n\n/* WEB WORKER */\n\nfunction DRACOWorker() {\n\n\tlet decoderConfig;\n\tlet decoderPending;\n\n\tonmessage = function ( e ) {\n\n\t\tconst message = e.data;\n\n\t\tswitch ( message.type ) {\n\n\t\t\tcase 'init':\n\t\t\t\tdecoderConfig = message.decoderConfig;\n\t\t\t\tdecoderPending = new Promise( function ( resolve/*, reject*/ ) {\n\n\t\t\t\t\tdecoderConfig.onModuleLoaded = function ( draco ) {\n\n\t\t\t\t\t\t// Module is Promise-like. Wrap before resolving to avoid loop.\n\t\t\t\t\t\tresolve( { draco: draco } );\n\n\t\t\t\t\t};\n\n\t\t\t\t\tDracoDecoderModule( decoderConfig ); // eslint-disable-line no-undef\n\n\t\t\t\t} );\n\t\t\t\tbreak;\n\n\t\t\tcase 'decode':\n\t\t\t\tconst buffer = message.buffer;\n\t\t\t\tconst taskConfig = message.taskConfig;\n\t\t\t\tdecoderPending.then( ( module ) => {\n\n\t\t\t\t\tconst draco = module.draco;\n\t\t\t\t\tconst decoder = new draco.Decoder();\n\t\t\t\t\tconst decoderBuffer = new draco.DecoderBuffer();\n\t\t\t\t\tdecoderBuffer.Init( new Int8Array( buffer ), buffer.byteLength );\n\n\t\t\t\t\ttry {\n\n\t\t\t\t\t\tconst geometry = decodeGeometry( draco, decoder, decoderBuffer, taskConfig );\n\n\t\t\t\t\t\tconst buffers = geometry.attributes.map( ( attr ) => attr.array.buffer );\n\n\t\t\t\t\t\tif ( geometry.index ) buffers.push( geometry.index.array.buffer );\n\n\t\t\t\t\t\tself.postMessage( { type: 'decode', id: message.id, geometry }, buffers );\n\n\t\t\t\t\t} catch ( error ) {\n\n\t\t\t\t\t\tconsole.error( error );\n\n\t\t\t\t\t\tself.postMessage( { type: 'error', id: message.id, error: error.message } );\n\n\t\t\t\t\t} finally {\n\n\t\t\t\t\t\tdraco.destroy( decoderBuffer );\n\t\t\t\t\t\tdraco.destroy( decoder );\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\t\t\t\tbreak;\n\n\t\t}\n\n\t};\n\n\tfunction decodeGeometry( draco, decoder, decoderBuffer, taskConfig ) {\n\n\t\tconst attributeIDs = taskConfig.attributeIDs;\n\t\tconst attributeTypes = taskConfig.attributeTypes;\n\n\t\tlet dracoGeometry;\n\t\tlet decodingStatus;\n\n\t\tconst geometryType = decoder.GetEncodedGeometryType( decoderBuffer );\n\n\t\tif ( geometryType === draco.TRIANGULAR_MESH ) {\n\n\t\t\tdracoGeometry = new draco.Mesh();\n\t\t\tdecodingStatus = decoder.DecodeBufferToMesh( decoderBuffer, dracoGeometry );\n\n\t\t} else if ( geometryType === draco.POINT_CLOUD ) {\n\n\t\t\tdracoGeometry = new draco.PointCloud();\n\t\t\tdecodingStatus = decoder.DecodeBufferToPointCloud( decoderBuffer, dracoGeometry );\n\n\t\t} else {\n\n\t\t\tthrow new Error( 'THREE.DRACOLoader: Unexpected geometry type.' );\n\n\t\t}\n\n\t\tif ( ! decodingStatus.ok() || dracoGeometry.ptr === 0 ) {\n\n\t\t\tthrow new Error( 'THREE.DRACOLoader: Decoding failed: ' + decodingStatus.error_msg() );\n\n\t\t}\n\n\t\tconst geometry = { index: null, attributes: [] };\n\n\t\t// Gather all vertex attributes.\n\t\tfor ( const attributeName in attributeIDs ) {\n\n\t\t\tconst attributeType = self[ attributeTypes[ attributeName ] ];\n\n\t\t\tlet attribute;\n\t\t\tlet attributeID;\n\n\t\t\t// A Draco file may be created with default vertex attributes, whose attribute IDs\n\t\t\t// are mapped 1:1 from their semantic name (POSITION, NORMAL, ...). Alternatively,\n\t\t\t// a Draco file may contain a custom set of attributes, identified by known unique\n\t\t\t// IDs. glTF files always do the latter, and `.drc` files typically do the former.\n\t\t\tif ( taskConfig.useUniqueIDs ) {\n\n\t\t\t\tattributeID = attributeIDs[ attributeName ];\n\t\t\t\tattribute = decoder.GetAttributeByUniqueId( dracoGeometry, attributeID );\n\n\t\t\t} else {\n\n\t\t\t\tattributeID = decoder.GetAttributeId( dracoGeometry, draco[ attributeIDs[ attributeName ] ] );\n\n\t\t\t\tif ( attributeID === - 1 ) continue;\n\n\t\t\t\tattribute = decoder.GetAttribute( dracoGeometry, attributeID );\n\n\t\t\t}\n\n\t\t\tgeometry.attributes.push( decodeAttribute( draco, decoder, dracoGeometry, attributeName, attributeType, attribute ) );\n\n\t\t}\n\n\t\t// Add index.\n\t\tif ( geometryType === draco.TRIANGULAR_MESH ) {\n\n\t\t\tgeometry.index = decodeIndex( draco, decoder, dracoGeometry );\n\n\t\t}\n\n\t\tdraco.destroy( dracoGeometry );\n\n\t\treturn geometry;\n\n\t}\n\n\tfunction decodeIndex( draco, decoder, dracoGeometry ) {\n\n\t\tconst numFaces = dracoGeometry.num_faces();\n\t\tconst numIndices = numFaces * 3;\n\t\tconst byteLength = numIndices * 4;\n\n\t\tconst ptr = draco._malloc( byteLength );\n\t\tdecoder.GetTrianglesUInt32Array( dracoGeometry, byteLength, ptr );\n\t\tconst index = new Uint32Array( draco.HEAPF32.buffer, ptr, numIndices ).slice();\n\t\tdraco._free( ptr );\n\n\t\treturn { array: index, itemSize: 1 };\n\n\t}\n\n\tfunction decodeAttribute( draco, decoder, dracoGeometry, attributeName, attributeType, attribute ) {\n\n\t\tconst numComponents = attribute.num_components();\n\t\tconst numPoints = dracoGeometry.num_points();\n\t\tconst numValues = numPoints * numComponents;\n\t\tconst byteLength = numValues * attributeType.BYTES_PER_ELEMENT;\n\t\tconst dataType = getDracoDataType( draco, attributeType );\n\n\t\tconst ptr = draco._malloc( byteLength );\n\t\tdecoder.GetAttributeDataArrayForAllPoints( dracoGeometry, attribute, dataType, byteLength, ptr );\n\t\tconst array = new attributeType( draco.HEAPF32.buffer, ptr, numValues ).slice();\n\t\tdraco._free( ptr );\n\n\t\treturn {\n\t\t\tname: attributeName,\n\t\t\tarray: array,\n\t\t\titemSize: numComponents\n\t\t};\n\n\t}\n\n\tfunction getDracoDataType( draco, attributeType ) {\n\n\t\tswitch ( attributeType ) {\n\n\t\t\tcase Float32Array: return draco.DT_FLOAT32;\n\t\t\tcase Int8Array: return draco.DT_INT8;\n\t\t\tcase Int16Array: return draco.DT_INT16;\n\t\t\tcase Int32Array: return draco.DT_INT32;\n\t\t\tcase Uint8Array: return draco.DT_UINT8;\n\t\t\tcase Uint16Array: return draco.DT_UINT16;\n\t\t\tcase Uint32Array: return draco.DT_UINT32;\n\n\t\t}\n\n\t}\n\n}\n\nexport { DRACOLoader };\n"]},"metadata":{},"sourceType":"module"}