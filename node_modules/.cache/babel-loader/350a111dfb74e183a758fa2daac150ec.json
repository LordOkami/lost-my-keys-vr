{"ast":null,"code":"import { AnimationClip, AnimationMixer, Euler, Matrix4, Quaternion, QuaternionKeyframeTrack, SkeletonHelper, Vector2, Vector3, VectorKeyframeTrack } from 'three';\n\nfunction retarget(target, source) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var pos = new Vector3(),\n      quat = new Quaternion(),\n      scale = new Vector3(),\n      bindBoneMatrix = new Matrix4(),\n      relativeMatrix = new Matrix4(),\n      globalMatrix = new Matrix4();\n  options.preserveMatrix = options.preserveMatrix !== undefined ? options.preserveMatrix : true;\n  options.preservePosition = options.preservePosition !== undefined ? options.preservePosition : true;\n  options.preserveHipPosition = options.preserveHipPosition !== undefined ? options.preserveHipPosition : false;\n  options.useTargetMatrix = options.useTargetMatrix !== undefined ? options.useTargetMatrix : false;\n  options.hip = options.hip !== undefined ? options.hip : 'hip';\n  options.names = options.names || {};\n  var sourceBones = source.isObject3D ? source.skeleton.bones : getBones(source),\n      bones = target.isObject3D ? target.skeleton.bones : getBones(target);\n  var bindBones, bone, name, boneTo, bonesPosition; // reset bones\n\n  if (target.isObject3D) {\n    target.skeleton.pose();\n  } else {\n    options.useTargetMatrix = true;\n    options.preserveMatrix = false;\n  }\n\n  if (options.preservePosition) {\n    bonesPosition = [];\n\n    for (var i = 0; i < bones.length; i++) {\n      bonesPosition.push(bones[i].position.clone());\n    }\n  }\n\n  if (options.preserveMatrix) {\n    // reset matrix\n    target.updateMatrixWorld();\n    target.matrixWorld.identity(); // reset children matrix\n\n    for (var _i = 0; _i < target.children.length; ++_i) {\n      target.children[_i].updateMatrixWorld(true);\n    }\n  }\n\n  if (options.offsets) {\n    bindBones = [];\n\n    for (var _i2 = 0; _i2 < bones.length; ++_i2) {\n      bone = bones[_i2];\n      name = options.names[bone.name] || bone.name;\n\n      if (options.offsets && options.offsets[name]) {\n        bone.matrix.multiply(options.offsets[name]);\n        bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);\n        bone.updateMatrixWorld();\n      }\n\n      bindBones.push(bone.matrixWorld.clone());\n    }\n  }\n\n  for (var _i3 = 0; _i3 < bones.length; ++_i3) {\n    bone = bones[_i3];\n    name = options.names[bone.name] || bone.name;\n    boneTo = getBoneByName(name, sourceBones);\n    globalMatrix.copy(bone.matrixWorld);\n\n    if (boneTo) {\n      boneTo.updateMatrixWorld();\n\n      if (options.useTargetMatrix) {\n        relativeMatrix.copy(boneTo.matrixWorld);\n      } else {\n        relativeMatrix.copy(target.matrixWorld).invert();\n        relativeMatrix.multiply(boneTo.matrixWorld);\n      } // ignore scale to extract rotation\n\n\n      scale.setFromMatrixScale(relativeMatrix);\n      relativeMatrix.scale(scale.set(1 / scale.x, 1 / scale.y, 1 / scale.z)); // apply to global matrix\n\n      globalMatrix.makeRotationFromQuaternion(quat.setFromRotationMatrix(relativeMatrix));\n\n      if (target.isObject3D) {\n        var boneIndex = bones.indexOf(bone),\n            wBindMatrix = bindBones ? bindBones[boneIndex] : bindBoneMatrix.copy(target.skeleton.boneInverses[boneIndex]).invert();\n        globalMatrix.multiply(wBindMatrix);\n      }\n\n      globalMatrix.copyPosition(relativeMatrix);\n    }\n\n    if (bone.parent && bone.parent.isBone) {\n      bone.matrix.copy(bone.parent.matrixWorld).invert();\n      bone.matrix.multiply(globalMatrix);\n    } else {\n      bone.matrix.copy(globalMatrix);\n    }\n\n    if (options.preserveHipPosition && name === options.hip) {\n      bone.matrix.setPosition(pos.set(0, bone.position.y, 0));\n    }\n\n    bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);\n    bone.updateMatrixWorld();\n  }\n\n  if (options.preservePosition) {\n    for (var _i4 = 0; _i4 < bones.length; ++_i4) {\n      bone = bones[_i4];\n      name = options.names[bone.name] || bone.name;\n\n      if (name !== options.hip) {\n        bone.position.copy(bonesPosition[_i4]);\n      }\n    }\n  }\n\n  if (options.preserveMatrix) {\n    // restore matrix\n    target.updateMatrixWorld(true);\n  }\n}\n\nfunction retargetClip(target, source, clip) {\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  options.useFirstFramePosition = options.useFirstFramePosition !== undefined ? options.useFirstFramePosition : false;\n  options.fps = options.fps !== undefined ? options.fps : 30;\n  options.names = options.names || [];\n\n  if (!source.isObject3D) {\n    source = getHelperFromSkeleton(source);\n  }\n\n  var numFrames = Math.round(clip.duration * (options.fps / 1000) * 1000),\n      delta = 1 / options.fps,\n      convertedTracks = [],\n      mixer = new AnimationMixer(source),\n      bones = getBones(target.skeleton),\n      boneDatas = [];\n  var positionOffset, bone, boneTo, boneData, name;\n  mixer.clipAction(clip).play();\n  mixer.update(0);\n  source.updateMatrixWorld();\n\n  for (var i = 0; i < numFrames; ++i) {\n    var time = i * delta;\n    retarget(target, source, options);\n\n    for (var j = 0; j < bones.length; ++j) {\n      name = options.names[bones[j].name] || bones[j].name;\n      boneTo = getBoneByName(name, source.skeleton);\n\n      if (boneTo) {\n        bone = bones[j];\n        boneData = boneDatas[j] = boneDatas[j] || {\n          bone: bone\n        };\n\n        if (options.hip === name) {\n          if (!boneData.pos) {\n            boneData.pos = {\n              times: new Float32Array(numFrames),\n              values: new Float32Array(numFrames * 3)\n            };\n          }\n\n          if (options.useFirstFramePosition) {\n            if (i === 0) {\n              positionOffset = bone.position.clone();\n            }\n\n            bone.position.sub(positionOffset);\n          }\n\n          boneData.pos.times[i] = time;\n          bone.position.toArray(boneData.pos.values, i * 3);\n        }\n\n        if (!boneData.quat) {\n          boneData.quat = {\n            times: new Float32Array(numFrames),\n            values: new Float32Array(numFrames * 4)\n          };\n        }\n\n        boneData.quat.times[i] = time;\n        bone.quaternion.toArray(boneData.quat.values, i * 4);\n      }\n    }\n\n    mixer.update(delta);\n    source.updateMatrixWorld();\n  }\n\n  for (var _i5 = 0; _i5 < boneDatas.length; ++_i5) {\n    boneData = boneDatas[_i5];\n\n    if (boneData) {\n      if (boneData.pos) {\n        convertedTracks.push(new VectorKeyframeTrack('.bones[' + boneData.bone.name + '].position', boneData.pos.times, boneData.pos.values));\n      }\n\n      convertedTracks.push(new QuaternionKeyframeTrack('.bones[' + boneData.bone.name + '].quaternion', boneData.quat.times, boneData.quat.values));\n    }\n  }\n\n  mixer.uncacheAction(clip);\n  return new AnimationClip(clip.name, -1, convertedTracks);\n}\n\nfunction getHelperFromSkeleton(skeleton) {\n  var source = new SkeletonHelper(skeleton.bones[0]);\n  source.skeleton = skeleton;\n  return source;\n}\n\nfunction getSkeletonOffsets(target, source) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var targetParentPos = new Vector3(),\n      targetPos = new Vector3(),\n      sourceParentPos = new Vector3(),\n      sourcePos = new Vector3(),\n      targetDir = new Vector2(),\n      sourceDir = new Vector2();\n  options.hip = options.hip !== undefined ? options.hip : 'hip';\n  options.names = options.names || {};\n\n  if (!source.isObject3D) {\n    source = getHelperFromSkeleton(source);\n  }\n\n  var nameKeys = Object.keys(options.names),\n      nameValues = Object.values(options.names),\n      sourceBones = source.isObject3D ? source.skeleton.bones : getBones(source),\n      bones = target.isObject3D ? target.skeleton.bones : getBones(target),\n      offsets = [];\n  var bone, boneTo, name, i;\n  target.skeleton.pose();\n\n  for (i = 0; i < bones.length; ++i) {\n    bone = bones[i];\n    name = options.names[bone.name] || bone.name;\n    boneTo = getBoneByName(name, sourceBones);\n\n    if (boneTo && name !== options.hip) {\n      var boneParent = getNearestBone(bone.parent, nameKeys),\n          boneToParent = getNearestBone(boneTo.parent, nameValues);\n      boneParent.updateMatrixWorld();\n      boneToParent.updateMatrixWorld();\n      targetParentPos.setFromMatrixPosition(boneParent.matrixWorld);\n      targetPos.setFromMatrixPosition(bone.matrixWorld);\n      sourceParentPos.setFromMatrixPosition(boneToParent.matrixWorld);\n      sourcePos.setFromMatrixPosition(boneTo.matrixWorld);\n      targetDir.subVectors(new Vector2(targetPos.x, targetPos.y), new Vector2(targetParentPos.x, targetParentPos.y)).normalize();\n      sourceDir.subVectors(new Vector2(sourcePos.x, sourcePos.y), new Vector2(sourceParentPos.x, sourceParentPos.y)).normalize();\n      var laterialAngle = targetDir.angle() - sourceDir.angle();\n      var offset = new Matrix4().makeRotationFromEuler(new Euler(0, 0, laterialAngle));\n      bone.matrix.multiply(offset);\n      bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);\n      bone.updateMatrixWorld();\n      offsets[name] = offset;\n    }\n  }\n\n  return offsets;\n}\n\nfunction renameBones(skeleton, names) {\n  var bones = getBones(skeleton);\n\n  for (var i = 0; i < bones.length; ++i) {\n    var bone = bones[i];\n\n    if (names[bone.name]) {\n      bone.name = names[bone.name];\n    }\n  }\n\n  return this;\n}\n\nfunction getBones(skeleton) {\n  return Array.isArray(skeleton) ? skeleton : skeleton.bones;\n}\n\nfunction getBoneByName(name, skeleton) {\n  for (var i = 0, bones = getBones(skeleton); i < bones.length; i++) {\n    if (name === bones[i].name) return bones[i];\n  }\n}\n\nfunction getNearestBone(bone, names) {\n  while (bone.isBone) {\n    if (names.indexOf(bone.name) !== -1) {\n      return bone;\n    }\n\n    bone = bone.parent;\n  }\n}\n\nfunction findBoneTrackData(name, tracks) {\n  var regexp = /\\[(.*)\\]\\.(.*)/,\n      result = {\n    name: name\n  };\n\n  for (var i = 0; i < tracks.length; ++i) {\n    // 1 is track name\n    // 2 is track type\n    var trackData = regexp.exec(tracks[i].name);\n\n    if (trackData && name === trackData[1]) {\n      result[trackData[2]] = i;\n    }\n  }\n\n  return result;\n}\n\nfunction getEqualsBonesNames(skeleton, targetSkeleton) {\n  var sourceBones = getBones(skeleton),\n      targetBones = getBones(targetSkeleton),\n      bones = [];\n\n  search: for (var i = 0; i < sourceBones.length; i++) {\n    var boneName = sourceBones[i].name;\n\n    for (var j = 0; j < targetBones.length; j++) {\n      if (boneName === targetBones[j].name) {\n        bones.push(boneName);\n        continue search;\n      }\n    }\n  }\n\n  return bones;\n}\n\nfunction clone(source) {\n  var sourceLookup = new Map();\n  var cloneLookup = new Map();\n  var clone = source.clone();\n  parallelTraverse(source, clone, function (sourceNode, clonedNode) {\n    sourceLookup.set(clonedNode, sourceNode);\n    cloneLookup.set(sourceNode, clonedNode);\n  });\n  clone.traverse(function (node) {\n    if (!node.isSkinnedMesh) return;\n    var clonedMesh = node;\n    var sourceMesh = sourceLookup.get(node);\n    var sourceBones = sourceMesh.skeleton.bones;\n    clonedMesh.skeleton = sourceMesh.skeleton.clone();\n    clonedMesh.bindMatrix.copy(sourceMesh.bindMatrix);\n    clonedMesh.skeleton.bones = sourceBones.map(function (bone) {\n      return cloneLookup.get(bone);\n    });\n    clonedMesh.bind(clonedMesh.skeleton, clonedMesh.bindMatrix);\n  });\n  return clone;\n}\n\nfunction parallelTraverse(a, b, callback) {\n  callback(a, b);\n\n  for (var i = 0; i < a.children.length; i++) {\n    parallelTraverse(a.children[i], b.children[i], callback);\n  }\n}\n\nexport { retarget, retargetClip, getHelperFromSkeleton, getSkeletonOffsets, renameBones, getBones, getBoneByName, getNearestBone, findBoneTrackData, getEqualsBonesNames, clone };","map":{"version":3,"sources":["/Users/lordokami/lordokami/lost-my-keys-vr/node_modules/three/examples/jsm/utils/SkeletonUtils.js"],"names":["AnimationClip","AnimationMixer","Euler","Matrix4","Quaternion","QuaternionKeyframeTrack","SkeletonHelper","Vector2","Vector3","VectorKeyframeTrack","retarget","target","source","options","pos","quat","scale","bindBoneMatrix","relativeMatrix","globalMatrix","preserveMatrix","undefined","preservePosition","preserveHipPosition","useTargetMatrix","hip","names","sourceBones","isObject3D","skeleton","bones","getBones","bindBones","bone","name","boneTo","bonesPosition","pose","i","length","push","position","clone","updateMatrixWorld","matrixWorld","identity","children","offsets","matrix","multiply","decompose","quaternion","getBoneByName","copy","invert","setFromMatrixScale","set","x","y","z","makeRotationFromQuaternion","setFromRotationMatrix","boneIndex","indexOf","wBindMatrix","boneInverses","copyPosition","parent","isBone","setPosition","retargetClip","clip","useFirstFramePosition","fps","getHelperFromSkeleton","numFrames","Math","round","duration","delta","convertedTracks","mixer","boneDatas","positionOffset","boneData","clipAction","play","update","time","j","times","Float32Array","values","sub","toArray","uncacheAction","getSkeletonOffsets","targetParentPos","targetPos","sourceParentPos","sourcePos","targetDir","sourceDir","nameKeys","Object","keys","nameValues","boneParent","getNearestBone","boneToParent","setFromMatrixPosition","subVectors","normalize","laterialAngle","angle","offset","makeRotationFromEuler","renameBones","Array","isArray","findBoneTrackData","tracks","regexp","result","trackData","exec","getEqualsBonesNames","targetSkeleton","targetBones","search","boneName","sourceLookup","Map","cloneLookup","parallelTraverse","sourceNode","clonedNode","traverse","node","isSkinnedMesh","clonedMesh","sourceMesh","get","bindMatrix","map","bind","a","b","callback"],"mappings":"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","sourcesContent":["import {\n\tAnimationClip,\n\tAnimationMixer,\n\tEuler,\n\tMatrix4,\n\tQuaternion,\n\tQuaternionKeyframeTrack,\n\tSkeletonHelper,\n\tVector2,\n\tVector3,\n\tVectorKeyframeTrack\n} from 'three';\n\n\nfunction retarget( target, source, options = {} ) {\n\n\tconst pos = new Vector3(),\n\t\tquat = new Quaternion(),\n\t\tscale = new Vector3(),\n\t\tbindBoneMatrix = new Matrix4(),\n\t\trelativeMatrix = new Matrix4(),\n\t\tglobalMatrix = new Matrix4();\n\n\toptions.preserveMatrix = options.preserveMatrix !== undefined ? options.preserveMatrix : true;\n\toptions.preservePosition = options.preservePosition !== undefined ? options.preservePosition : true;\n\toptions.preserveHipPosition = options.preserveHipPosition !== undefined ? options.preserveHipPosition : false;\n\toptions.useTargetMatrix = options.useTargetMatrix !== undefined ? options.useTargetMatrix : false;\n\toptions.hip = options.hip !== undefined ? options.hip : 'hip';\n\toptions.names = options.names || {};\n\n\tconst sourceBones = source.isObject3D ? source.skeleton.bones : getBones( source ),\n\t\tbones = target.isObject3D ? target.skeleton.bones : getBones( target );\n\n\tlet bindBones,\n\t\tbone, name, boneTo,\n\t\tbonesPosition;\n\n\t// reset bones\n\n\tif ( target.isObject3D ) {\n\n\t\ttarget.skeleton.pose();\n\n\t} else {\n\n\t\toptions.useTargetMatrix = true;\n\t\toptions.preserveMatrix = false;\n\n\t}\n\n\tif ( options.preservePosition ) {\n\n\t\tbonesPosition = [];\n\n\t\tfor ( let i = 0; i < bones.length; i ++ ) {\n\n\t\t\tbonesPosition.push( bones[ i ].position.clone() );\n\n\t\t}\n\n\t}\n\n\tif ( options.preserveMatrix ) {\n\n\t\t// reset matrix\n\n\t\ttarget.updateMatrixWorld();\n\n\t\ttarget.matrixWorld.identity();\n\n\t\t// reset children matrix\n\n\t\tfor ( let i = 0; i < target.children.length; ++ i ) {\n\n\t\t\ttarget.children[ i ].updateMatrixWorld( true );\n\n\t\t}\n\n\t}\n\n\tif ( options.offsets ) {\n\n\t\tbindBones = [];\n\n\t\tfor ( let i = 0; i < bones.length; ++ i ) {\n\n\t\t\tbone = bones[ i ];\n\t\t\tname = options.names[ bone.name ] || bone.name;\n\n\t\t\tif ( options.offsets && options.offsets[ name ] ) {\n\n\t\t\t\tbone.matrix.multiply( options.offsets[ name ] );\n\n\t\t\t\tbone.matrix.decompose( bone.position, bone.quaternion, bone.scale );\n\n\t\t\t\tbone.updateMatrixWorld();\n\n\t\t\t}\n\n\t\t\tbindBones.push( bone.matrixWorld.clone() );\n\n\t\t}\n\n\t}\n\n\tfor ( let i = 0; i < bones.length; ++ i ) {\n\n\t\tbone = bones[ i ];\n\t\tname = options.names[ bone.name ] || bone.name;\n\n\t\tboneTo = getBoneByName( name, sourceBones );\n\n\t\tglobalMatrix.copy( bone.matrixWorld );\n\n\t\tif ( boneTo ) {\n\n\t\t\tboneTo.updateMatrixWorld();\n\n\t\t\tif ( options.useTargetMatrix ) {\n\n\t\t\t\trelativeMatrix.copy( boneTo.matrixWorld );\n\n\t\t\t} else {\n\n\t\t\t\trelativeMatrix.copy( target.matrixWorld ).invert();\n\t\t\t\trelativeMatrix.multiply( boneTo.matrixWorld );\n\n\t\t\t}\n\n\t\t\t// ignore scale to extract rotation\n\n\t\t\tscale.setFromMatrixScale( relativeMatrix );\n\t\t\trelativeMatrix.scale( scale.set( 1 / scale.x, 1 / scale.y, 1 / scale.z ) );\n\n\t\t\t// apply to global matrix\n\n\t\t\tglobalMatrix.makeRotationFromQuaternion( quat.setFromRotationMatrix( relativeMatrix ) );\n\n\t\t\tif ( target.isObject3D ) {\n\n\t\t\t\tconst boneIndex = bones.indexOf( bone ),\n\t\t\t\t\twBindMatrix = bindBones ? bindBones[ boneIndex ] : bindBoneMatrix.copy( target.skeleton.boneInverses[ boneIndex ] ).invert();\n\n\t\t\t\tglobalMatrix.multiply( wBindMatrix );\n\n\t\t\t}\n\n\t\t\tglobalMatrix.copyPosition( relativeMatrix );\n\n\t\t}\n\n\t\tif ( bone.parent && bone.parent.isBone ) {\n\n\t\t\tbone.matrix.copy( bone.parent.matrixWorld ).invert();\n\t\t\tbone.matrix.multiply( globalMatrix );\n\n\t\t} else {\n\n\t\t\tbone.matrix.copy( globalMatrix );\n\n\t\t}\n\n\t\tif ( options.preserveHipPosition && name === options.hip ) {\n\n\t\t\tbone.matrix.setPosition( pos.set( 0, bone.position.y, 0 ) );\n\n\t\t}\n\n\t\tbone.matrix.decompose( bone.position, bone.quaternion, bone.scale );\n\n\t\tbone.updateMatrixWorld();\n\n\t}\n\n\tif ( options.preservePosition ) {\n\n\t\tfor ( let i = 0; i < bones.length; ++ i ) {\n\n\t\t\tbone = bones[ i ];\n\t\t\tname = options.names[ bone.name ] || bone.name;\n\n\t\t\tif ( name !== options.hip ) {\n\n\t\t\t\tbone.position.copy( bonesPosition[ i ] );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tif ( options.preserveMatrix ) {\n\n\t\t// restore matrix\n\n\t\ttarget.updateMatrixWorld( true );\n\n\t}\n\n}\n\nfunction retargetClip( target, source, clip, options = {} ) {\n\n\toptions.useFirstFramePosition = options.useFirstFramePosition !== undefined ? options.useFirstFramePosition : false;\n\toptions.fps = options.fps !== undefined ? options.fps : 30;\n\toptions.names = options.names || [];\n\n\tif ( ! source.isObject3D ) {\n\n\t\tsource = getHelperFromSkeleton( source );\n\n\t}\n\n\tconst numFrames = Math.round( clip.duration * ( options.fps / 1000 ) * 1000 ),\n\t\tdelta = 1 / options.fps,\n\t\tconvertedTracks = [],\n\t\tmixer = new AnimationMixer( source ),\n\t\tbones = getBones( target.skeleton ),\n\t\tboneDatas = [];\n\tlet positionOffset,\n\t\tbone, boneTo, boneData,\n\t\tname;\n\n\tmixer.clipAction( clip ).play();\n\tmixer.update( 0 );\n\n\tsource.updateMatrixWorld();\n\n\tfor ( let i = 0; i < numFrames; ++ i ) {\n\n\t\tconst time = i * delta;\n\n\t\tretarget( target, source, options );\n\n\t\tfor ( let j = 0; j < bones.length; ++ j ) {\n\n\t\t\tname = options.names[ bones[ j ].name ] || bones[ j ].name;\n\n\t\t\tboneTo = getBoneByName( name, source.skeleton );\n\n\t\t\tif ( boneTo ) {\n\n\t\t\t\tbone = bones[ j ];\n\t\t\t\tboneData = boneDatas[ j ] = boneDatas[ j ] || { bone: bone };\n\n\t\t\t\tif ( options.hip === name ) {\n\n\t\t\t\t\tif ( ! boneData.pos ) {\n\n\t\t\t\t\t\tboneData.pos = {\n\t\t\t\t\t\t\ttimes: new Float32Array( numFrames ),\n\t\t\t\t\t\t\tvalues: new Float32Array( numFrames * 3 )\n\t\t\t\t\t\t};\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( options.useFirstFramePosition ) {\n\n\t\t\t\t\t\tif ( i === 0 ) {\n\n\t\t\t\t\t\t\tpositionOffset = bone.position.clone();\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbone.position.sub( positionOffset );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tboneData.pos.times[ i ] = time;\n\n\t\t\t\t\tbone.position.toArray( boneData.pos.values, i * 3 );\n\n\t\t\t\t}\n\n\t\t\t\tif ( ! boneData.quat ) {\n\n\t\t\t\t\tboneData.quat = {\n\t\t\t\t\t\ttimes: new Float32Array( numFrames ),\n\t\t\t\t\t\tvalues: new Float32Array( numFrames * 4 )\n\t\t\t\t\t};\n\n\t\t\t\t}\n\n\t\t\t\tboneData.quat.times[ i ] = time;\n\n\t\t\t\tbone.quaternion.toArray( boneData.quat.values, i * 4 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tmixer.update( delta );\n\n\t\tsource.updateMatrixWorld();\n\n\t}\n\n\tfor ( let i = 0; i < boneDatas.length; ++ i ) {\n\n\t\tboneData = boneDatas[ i ];\n\n\t\tif ( boneData ) {\n\n\t\t\tif ( boneData.pos ) {\n\n\t\t\t\tconvertedTracks.push( new VectorKeyframeTrack(\n\t\t\t\t\t'.bones[' + boneData.bone.name + '].position',\n\t\t\t\t\tboneData.pos.times,\n\t\t\t\t\tboneData.pos.values\n\t\t\t\t) );\n\n\t\t\t}\n\n\t\t\tconvertedTracks.push( new QuaternionKeyframeTrack(\n\t\t\t\t'.bones[' + boneData.bone.name + '].quaternion',\n\t\t\t\tboneData.quat.times,\n\t\t\t\tboneData.quat.values\n\t\t\t) );\n\n\t\t}\n\n\t}\n\n\tmixer.uncacheAction( clip );\n\n\treturn new AnimationClip( clip.name, - 1, convertedTracks );\n\n}\n\nfunction getHelperFromSkeleton( skeleton ) {\n\n\tconst source = new SkeletonHelper( skeleton.bones[ 0 ] );\n\tsource.skeleton = skeleton;\n\n\treturn source;\n\n}\n\nfunction getSkeletonOffsets( target, source, options = {} ) {\n\n\tconst targetParentPos = new Vector3(),\n\t\ttargetPos = new Vector3(),\n\t\tsourceParentPos = new Vector3(),\n\t\tsourcePos = new Vector3(),\n\t\ttargetDir = new Vector2(),\n\t\tsourceDir = new Vector2();\n\n\toptions.hip = options.hip !== undefined ? options.hip : 'hip';\n\toptions.names = options.names || {};\n\n\tif ( ! source.isObject3D ) {\n\n\t\tsource = getHelperFromSkeleton( source );\n\n\t}\n\n\tconst nameKeys = Object.keys( options.names ),\n\t\tnameValues = Object.values( options.names ),\n\t\tsourceBones = source.isObject3D ? source.skeleton.bones : getBones( source ),\n\t\tbones = target.isObject3D ? target.skeleton.bones : getBones( target ),\n\t\toffsets = [];\n\n\tlet bone, boneTo,\n\t\tname, i;\n\n\ttarget.skeleton.pose();\n\n\tfor ( i = 0; i < bones.length; ++ i ) {\n\n\t\tbone = bones[ i ];\n\t\tname = options.names[ bone.name ] || bone.name;\n\n\t\tboneTo = getBoneByName( name, sourceBones );\n\n\t\tif ( boneTo && name !== options.hip ) {\n\n\t\t\tconst boneParent = getNearestBone( bone.parent, nameKeys ),\n\t\t\t\tboneToParent = getNearestBone( boneTo.parent, nameValues );\n\n\t\t\tboneParent.updateMatrixWorld();\n\t\t\tboneToParent.updateMatrixWorld();\n\n\t\t\ttargetParentPos.setFromMatrixPosition( boneParent.matrixWorld );\n\t\t\ttargetPos.setFromMatrixPosition( bone.matrixWorld );\n\n\t\t\tsourceParentPos.setFromMatrixPosition( boneToParent.matrixWorld );\n\t\t\tsourcePos.setFromMatrixPosition( boneTo.matrixWorld );\n\n\t\t\ttargetDir.subVectors(\n\t\t\t\tnew Vector2( targetPos.x, targetPos.y ),\n\t\t\t\tnew Vector2( targetParentPos.x, targetParentPos.y )\n\t\t\t).normalize();\n\n\t\t\tsourceDir.subVectors(\n\t\t\t\tnew Vector2( sourcePos.x, sourcePos.y ),\n\t\t\t\tnew Vector2( sourceParentPos.x, sourceParentPos.y )\n\t\t\t).normalize();\n\n\t\t\tconst laterialAngle = targetDir.angle() - sourceDir.angle();\n\n\t\t\tconst offset = new Matrix4().makeRotationFromEuler(\n\t\t\t\tnew Euler(\n\t\t\t\t\t0,\n\t\t\t\t\t0,\n\t\t\t\t\tlaterialAngle\n\t\t\t\t)\n\t\t\t);\n\n\t\t\tbone.matrix.multiply( offset );\n\n\t\t\tbone.matrix.decompose( bone.position, bone.quaternion, bone.scale );\n\n\t\t\tbone.updateMatrixWorld();\n\n\t\t\toffsets[ name ] = offset;\n\n\t\t}\n\n\t}\n\n\treturn offsets;\n\n}\n\nfunction renameBones( skeleton, names ) {\n\n\tconst bones = getBones( skeleton );\n\n\tfor ( let i = 0; i < bones.length; ++ i ) {\n\n\t\tconst bone = bones[ i ];\n\n\t\tif ( names[ bone.name ] ) {\n\n\t\t\tbone.name = names[ bone.name ];\n\n\t\t}\n\n\t}\n\n\treturn this;\n\n}\n\nfunction getBones( skeleton ) {\n\n\treturn Array.isArray( skeleton ) ? skeleton : skeleton.bones;\n\n}\n\nfunction getBoneByName( name, skeleton ) {\n\n\tfor ( let i = 0, bones = getBones( skeleton ); i < bones.length; i ++ ) {\n\n\t\tif ( name === bones[ i ].name )\n\n\t\t\treturn bones[ i ];\n\n\t}\n\n}\n\nfunction getNearestBone( bone, names ) {\n\n\twhile ( bone.isBone ) {\n\n\t\tif ( names.indexOf( bone.name ) !== - 1 ) {\n\n\t\t\treturn bone;\n\n\t\t}\n\n\t\tbone = bone.parent;\n\n\t}\n\n}\n\nfunction findBoneTrackData( name, tracks ) {\n\n\tconst regexp = /\\[(.*)\\]\\.(.*)/,\n\t\tresult = { name: name };\n\n\tfor ( let i = 0; i < tracks.length; ++ i ) {\n\n\t\t// 1 is track name\n\t\t// 2 is track type\n\t\tconst trackData = regexp.exec( tracks[ i ].name );\n\n\t\tif ( trackData && name === trackData[ 1 ] ) {\n\n\t\t\tresult[ trackData[ 2 ] ] = i;\n\n\t\t}\n\n\t}\n\n\treturn result;\n\n}\n\nfunction getEqualsBonesNames( skeleton, targetSkeleton ) {\n\n\tconst sourceBones = getBones( skeleton ),\n\t\ttargetBones = getBones( targetSkeleton ),\n\t\tbones = [];\n\n\tsearch : for ( let i = 0; i < sourceBones.length; i ++ ) {\n\n\t\tconst boneName = sourceBones[ i ].name;\n\n\t\tfor ( let j = 0; j < targetBones.length; j ++ ) {\n\n\t\t\tif ( boneName === targetBones[ j ].name ) {\n\n\t\t\t\tbones.push( boneName );\n\n\t\t\t\tcontinue search;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn bones;\n\n}\n\nfunction clone( source ) {\n\n\tconst sourceLookup = new Map();\n\tconst cloneLookup = new Map();\n\n\tconst clone = source.clone();\n\n\tparallelTraverse( source, clone, function ( sourceNode, clonedNode ) {\n\n\t\tsourceLookup.set( clonedNode, sourceNode );\n\t\tcloneLookup.set( sourceNode, clonedNode );\n\n\t} );\n\n\tclone.traverse( function ( node ) {\n\n\t\tif ( ! node.isSkinnedMesh ) return;\n\n\t\tconst clonedMesh = node;\n\t\tconst sourceMesh = sourceLookup.get( node );\n\t\tconst sourceBones = sourceMesh.skeleton.bones;\n\n\t\tclonedMesh.skeleton = sourceMesh.skeleton.clone();\n\t\tclonedMesh.bindMatrix.copy( sourceMesh.bindMatrix );\n\n\t\tclonedMesh.skeleton.bones = sourceBones.map( function ( bone ) {\n\n\t\t\treturn cloneLookup.get( bone );\n\n\t\t} );\n\n\t\tclonedMesh.bind( clonedMesh.skeleton, clonedMesh.bindMatrix );\n\n\t} );\n\n\treturn clone;\n\n}\n\n\n\n\nfunction parallelTraverse( a, b, callback ) {\n\n\tcallback( a, b );\n\n\tfor ( let i = 0; i < a.children.length; i ++ ) {\n\n\t\tparallelTraverse( a.children[ i ], b.children[ i ], callback );\n\n\t}\n\n}\n\nexport {\n\tretarget,\n\tretargetClip,\n\tgetHelperFromSkeleton,\n\tgetSkeletonOffsets,\n\trenameBones,\n\tgetBones,\n\tgetBoneByName,\n\tgetNearestBone,\n\tfindBoneTrackData,\n\tgetEqualsBonesNames,\n\tclone,\n};\n"]},"metadata":{},"sourceType":"module"}